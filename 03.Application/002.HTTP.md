# 2. HTTP

## (1) 개요

### 1) HTTP 프로토콜은 웹 상에서 클라이언트와 서버 간 통신을 위해 개발된 프로토콜이다.

- 웹의 정식 명칭은 월드 와이드 웹(WWW: World Wide Web)으로 전 세계에 거미줄처럼 연결된 망이라는 의미이다.
- 다양한 하이퍼텍스트(Hyper Text) 문서들이 웹상에서 서로 연결되어 있다. 하이퍼텍스트 문서란 참조 혹은 링크를 통해 한 문서에서 다른 문서로 접근할 수 있는 문서를 말한다. 대표적인 하이퍼텍스트 문서로  HTML이 있다.
- 주로 80/tcp 포트를 사용하며 1991년 HTTP 초기 버전(0.9)이 발표된 이후 1996년 1.0버전, 1999년 1.1버전이 발표되어 널리 사용되고 있다.
- HTTP 통신은 클라이언트 요청과 서버 응답으로 이루어져 있다.

### 2) 비연결형(Connectionless) 프로토콜

1.HTTP/1.0 버전까지는 클라이언트의 HTTP요청에 대한 서버의 HTTP 응답 이후에 TCP 연결을 바로 종료하는 구조 동작한다. 

- 연결을 바로 종료하는 이유는 제한된 서버(웹서버) 연결 자원을 이용하여 최대한 많은 클라이언트의 요청을 처리하기 위함이다.
- 서버(웹서버) 입장에서는 통신을 위한 다수의 TCP 연결 설정 및 종료에 대한 부하가 있다.

2.HTTP/1.1 버전부터 Connection헤더에 Keep-Alive 옵션이 추가되었다. 이는 TCP연결 상태를 웹서버 설정에 따라 일정 시간 지속시키는 옵션으로 한 번의 연결 이후에 요청/응답을 반복할 수 있다. 

- HTTP 응답 메시지를 분석해보면, 일반적으로 이미지, 스크립트 등 다수의 추가 자원 요청이 발생한다. 따라서 TCP 연결 설정 및 종료에 대한 부하를 줄이면서 효율적으로 클라이언트 요청을 처리하기 위해 연결 상태를 일정 시간 유지하는 옵션이 추가되었다.
- 최초 클라이언트 요청 시 웹서버는 Connection 응답 헤서에 Keep-Alive 옵션을 설정하고  Keep-Alive 응답헤더에 추가 옵션을 설정한다.

```json
HTTP/1.1 200 OK
Connection: Keep-Alive
Content-Type: text/html: charset=UTF-8
Date: Sun, 14 May 2023 01:50:59 GMT
Content-Length: 1875
Keep-Alive: timeout=10, max=20
```

- 위 예를 살펴보면 timeout은 연결 지속 시간으로 10초로 설정되어 있으며, max는 연결을 지속하는 동안 허용할 최대 요청 건수로 20건이 설정되어 있다.
- 아파치 웹서버 설정파일(http.conf)의 Keep-Alive 관련 설정은 다음과 같다.

```json
#KeppAlive On 
KeppAlive On 

MaxKeepAliveRequests 100 

KeepAliveTimeout 15 
```

### 3) 상태정보를 유지하지 않는(Stateless) 프로토콜

- 상태 정보를 유지하지 않는다는 것은 동일한 클라이언트의 현재 요청과 이전 요청을 식별하지 못한다는 의미이다. 즉 현재 연결에 대한 클라이언트의 어떤 상태 정보도 유지하지 않는다는 의미이다.
- 서비스 특성상 클라이언트의 상태정보 유지가 필요할 수 있다. 대표적으로 쇼핑몰의 장바구니 같은 기능이나 로그인 상태 유지 등이 있다.
- 클라이언트 상태정보를 유지하기 위한 클라이언트 사이드에서는 쿠키 서버 사이드에서는 세션을 사용할 수 있다.

## (2) 클라이언트 상태 정보 유지 기술

### 1) 쿠키(Cookie)

- 쿠키는 개별 클라이언트 상태 정보를 HTTP 요청/응답 헤더에 담아서 전달하는 작은 정보/데이터를 말한다.
- 서버에서 ‘Set-Cookie 응답헤더’를 통해 쿠키를 설정하여 클라이언트로 전달하면 클라이언트는 ‘Cookie 요청헤더’를 이용해 지속해서 쿠키를 전달하는 형태로 동작한다.
- 쿠키는 지속 시간에 따라 영속쿠키와 세션 쿠키로 구분할 수 있다. 
- 영속쿠키: 클라이언트에 파일형태로 지속해서(또는 일정 기간) 존재하는 쿠키로 쿠키에 설정된 사이트로 요청할 때마다 Cookie 요청헤더에 쿠키 정보를 담아서 전달한다. 
- 세션쿠키: 클라이언트 메모리상에 세션이 유지되는 동안 존재하는 쿠키로 세션이 종료되면(일반적으로 웹브라우저 종료시) 소멸한다.
- 쿠키 방식은 클라이언트 상태정보를 클라이언트에 저장하고 HTTP요청/응답헤더에 담아서 전달하기 때문에 해킹 및 스니핑 공격에 의한 변조와 외부 노출에 취약한 특성이 있다. 따라서 중요정보(개인정보, 신용정보, 비밀번호 등)를 저장할 경우에는 ‘쿠키 방식’이 아닌 서버에 상태 정보를 저장하는 “세션 방식”이 안전하며 부득이하게 쿠키를 사용해야 할 경우에는 암호화를 적용해야 한다.

### 2) 세션(Session)

- 세션은 개별 클라이언트 상태정보를 서버에 저장하는 기술이다.
- 서버는 개별 클라이언트 세션을 식별하기 위해 세션ID를 부여하고 세션ID는 세션쿠키를 이용하여 클라이언트와 서버 간에 주로 받는다.
- 클라이언트 상태 정보를 서버에 저장하기 때문에 쿠키 방식에 비해 보안상 안전하다는 장점이 있다.
- 만약 공격자가 정상적인 사용자의 세션 ID 정보를 탈취하면 정상 사용자로 위장한 접근이 가능하다. 이러한 공격을 **HTTP 세션 하이재킹**이라 한다.

## (3) HTTP 쿠키(Cookie) 관련 보안 속성

### 1) httponly 속성

- Set-Cookie 응답헤더에 설정하는 속성으로 클라이언트(웹 브라우저 등)에서 스크립트(자바스크립트)를 통해 해당 쿠키에 접근하는 것을 차단하는 속성이다.
- 일반적으로 세션ID를 저장하고 있는 세션쿠키를 탈취하기 위한 XSS(Cross Site Script)공격에 대응하기 위하여 사용한다.

### 2) secure 속성

- Set-Cookie 응답헤더에 설정하는 속성으로 클라이언트(웹 브라우저 등)에서 HTTPS(SSL/TLS) 통신을 경우에만 해당 쿠키를 전송하고 HTTP통신일 경우에는 전달하지 않는 속성이다.
- 전송 중에 평문 쿠키가 노출되는 것을 방지하기 위한 목적으로 쿠키에 대한 기밀성을 보장하기 위한 목적으로 사용된다.

## (4) HTTP 요청 메시지 구조

| 요청라인  | 요청 메소드<공백>요청URI<공백>HTTP버전<개행> |
| --- | --- |
| 요청헤더 | 헤더명:헤더값<개행> |
| … | … |
| 요청헤더 | 헤더명:헤더값<개행> |
| 빈 라인  | <개행> |
| 요청 메시지 바디 | 메시지 내용  |

### 1) 구문 형식

- 요청라인
: 한 행으로 구성되며 요청메소드, 요청 URI, HTTP 버전정보 등을 포함하고 있다.

 - <공백>
    : 아스키코드 헥사값으로  “0x20“으로 표현한다. 

 - <개행>
    :  제어문자로 CRLF(Carriage Return Line Feed), 아스키코드 헥사값으로 ‘0x0d0a’ 로 표현한다. 

- 요청헤더: 
여러 헤더로 구성되며 각각의 헤더정보는 개행으로 구분한다. 주요 요청 헤더 정보는 다음과 같다. 
- Host: 요청의 대상이되는 서버의 도메인명, 호스트명과 포트 정보
- User-Agent: 요청 클라이언트 애플리케이션의 정보/ OS정보
- Referer: 현재 요청 URL 정보를 담고 있는 이전 문서의 URL정보
- 빈 라인
: 헤더의 끝을 의미하는 개행이다. 헤더의 개수가 가변적이기 때문에 빈 라인을 통해 그 끝을 식별한다.
- 요청 메시지 바디
:  클라이언트에서 서버로 전송하는 데이터를 담는 부분이다. GET방식의 경우에는 요청 데이터가 없으므로 메시지 바디가 없다.

### 2) 주요 요청 메소드

| 메소드 | 설명 |
| --- | --- |
| GET | 요청 URI로 지정한 서버에 요청아는 메소드로 요청 메시지 바이가 없으며 필요시 쿼리스트링(Query String)을 이용하여 제한된 데이터 전송이 가능하다.  |
| POST | 요청URL로 지정한 자원에 데이터를 전달하여 이를 처리한 결과를 서버에 요청하는 메소드로 요청 메시지 바디를 포함한다.  |
| HEAD | GET메소드와 유사하게 요청하지만 서버 응답시 응답 메시지 바디를 제외하고 헤더부만 응답해주는 메소드로 요청 자원에 대한 처리는 서버에서 이루어지지만 그 결과로 헤더값만을 전송한다. 주로 섬색엔진에서 URL/링크의 유효성을 검증하기 위한 목적으로 사용한다.  |
| OPTIONS | 서버가 지원하는 메소드를 확인하는 목적으로 사용하는 메소드다. |
| CONNECT | 클라이언트와 서버간에 터널링 목적으로 사용하는 메소드로 웹 서버가 프록시(Proxy) 역할을 수행한다.  |
| PUT | 요청 메시지 바디에 포함되어 있는 데이터를 요청 URI로 지정한 자원으로 저장하도록하는 메소드다.  |
| TRACE | 클라이언트로부터 수신한 메시지를 서버에서 그대로 반환하는 메소드로 요청에 대한 루프백 테스트 용도로 사용하는 메소드이다.  |
| DELETE | 요청 URI로 지정한 자원을 서버에서 삭제하도록 하는 메소드다.  |
- 웹 애플리케이션에서 일반적으로 사용하는 GET, POST 이외의 불필요한 메소드를 허용할 경우 공격자가 이를 이용하여 웹 서버에 파일을 생성하거나 삭제 및 수정을 할 수 있으므로 이를 사용하지 못하도록 적절한 설정이 필요하다.

### 3) Query String(요청 문자열)

- GET방식의 쿼리스트링으로 전달하는 데이터는 요청 URI 끝에 추가해서 전달하기 때문에 주소창에 정보가 쉽게 노출되고 서버 엑세스(access) 로그 상에 그대로 남아 있다. 따라서 중요한 정보를 GET방식의 쿼리스트링으로 전달하는 것은 보안상 매우 취약하므로 중요한 정보는 POST방식으로 전달하는 것이 권장된다.

## (5) HTTP 요청 메시지 구조

| 상태라인  | HTTP버전<공백>상태코드<공백>응답구문<개행> |
| --- | --- |
| 응답헤더 | 헤더명:헤더값<개행> |
| … | … |
| 응답헤더 | 헤더명:헤더값<개행> |
| 빈 라인  | <개행> |
| 응답 메시지 바디 | 메시지 내용  |

### 1) 구문 형식

- 상태라인
: 한 행으로 구성되며 HTTP버전, 상태코드, 응답구문으로 이루어져 있다.
- 응답헤더: 
여러 헤더로 구성되며 각각의 헤더정보는 개행으로 구분한다. 주요 응답 헤더 정보는 다음과 같다. 
- Content-Type: 메시지 바디의 데이터 형식을 설정한다. 
- Content-Length: 메시지 바디의 전체 크기를 설정한다. (단위: 바이트)
- 빈 라인
: 헤더의 끝을 의미하는 개행이다. 헤더의 개수가 가변적이기 때문에 빈 라인을 통해 그 끝을 식별한다.
- 응답 메시지 바디
: 서버에서 클라이언트로 전송하는 데이터를 담는 부분이다.

### 2) 주요 상태 코드

1xx:  information(정보)

2xx: Success(성공)

3xx: Redirection(재지정 응답코드, 요청 자원의 위치가 재지정되었음을 의미)

4xx: Client Error(클라이언트 오류 응답 코드)

5xx: Server Error(서버 오류 응답 코드)

| 상태코드 | 설명 |
| --- | --- |
| 100 | Continue(클라이언트로부터 일부 요청을 받았으며, 나머지 정보를 계속 요청함) |
| 200 | OK(요청이 성공적으로 수행) |
| 201 | Created(원격지 서버에 파일이 생성됨) |
| 202 | Acccepted(웹 서버가 명령 수신함) |
| 301 | Moved Permanently(요청 자원의 위치가 영구적으로 변경됨, Location 응답 헤더를 통해 자원의 변경된 URL 정보 전달) |
| 302 | Found(요청자원의 위치가 임시적으로 변경됨. Location 응답 헤더를 통해 자원의 변경된 URL 정보 전달) |
| 304 | Not Modified(요청한 자원이 변경되지 않았으므로 클라이언트 로컬 캐시에 저장된 자원을 이용하라는 의미) |
| 400 | Bad Request(요청 메시지 문법 오류) |
| 401 | Unauthorized(요청한 자원에 대한 인가 필요, 요청 자우너을 실행하는데 필요한 적절한 권한이 없음을 의미) |
| 403 | Forbidden(요청한 자원에 대한 접근 차단) |
| 404 | Not Found(요청한 자원이 존재하지 않음) |
| 500 | Internal Server Error(내부 서버 오류) |