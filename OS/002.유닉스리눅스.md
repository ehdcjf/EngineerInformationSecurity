# UNIX/Linux 시스템 기본

### 시스템 접근

##### 로그인

1. 사용자 계정과 패스워드를 입력하면 로그인을 담당하는 프로그램은 입력한 패스워드와 /etc/passwd 파일의 해당 필드를 비교한다.
2. 패스워드 확인 후 로그인 프로그램은 쉘이 사용할 변수들을 근거로 초기 환경을 설정한다.
      - HOME: 사용자 홈디렉터리 지정
      - SHELL: 로그인 쉘 지정
      - USER 또는 LOGNAME: 사용자의 사용자 계정 지정
3. 모든 절차가 끝나면 로그인 쉘 실행

##### 로그아웃

- 유닉스 시스템에서 로그아웃을 할 때 사용하는 명령어는 `logout` 과 `exit`가 있으며 키보드의 `[Ctrl+d]` 조합키를 사용할 수도 있다.

### 사용자 정보

##### etc/passwd 파일

- UNIX는 시스템 관리자가 사용자 계정을 만들 때마다 사용자와 관련된 정보를 /etc/passwd 파일에 저장한다.

| account       | password                                               | UID       | GID         | comment               | home directory                             | login-shell |
| ------------- | ------------------------------------------------------ | --------- | ----------- | --------------------- | ------------------------------------------ | ----------- |
| 사용자 계정명 | 사용자 패스워드(x는 shadow 패스워드를 사용한다는 의미) | 사용자 ID | 기본그룹 ID | 사용자 관련 기타 정보 | 로그인 성공 후 사용자가 위치할 홈 디렉토리 | 로그인 쉘   |

```bash
$ cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
...
ehdcjf:x:1000:1000:ehdcjf,,,:/home/ehdcjf:/bin/bash
```

- 해킹 시 주로 UID, GID를 0으로 변경한다. 시스템은 UID,GID를 기준으로 권한을 부여하기 때문에 계정 이름이 root 가 아니라도 UID, GID가 0이면 root가 되는 것이다. 이는 윈도우의 보안식별자(SID) 500이 관리자인 것과 같은 개념이다.
- UID,GID 가 0으로 변경된 계정이 있는지 주기적으로 확인해 취약점을 제거해야한다. 로그인 쉘을 변경하여 사용자 로그인 시 악성 쉘이 실행되게 하는 예도 있으므로 주기적으로 변경 여부를 확인해야한다.

##### 사용자 확인 `id`

- 접속 중인 사용자를 확인하려면 id 명령을 사용한다.

```sh
$ id ehdcjf

uid=1000(ehdcjf) gid=1000(ehdcjf) groups=1000(ehdcjf),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)
```

##### 패스워드 변경 `passwd`

- 사용하던 패스워드를 변경하거나 패스워드가 없는 사용자 계정에 패스워드를 부여할때 passwd 명령을 사용한다.
- 일반 사용자는 자신의 패스워드만 변경할 수 있지만, 슈퍼 유저root는 자신을 포함하여 시스템에 등록된 모든 사용자의 패스워드를 변경할 수 있게 한다.

### 그룹정보

##### 그룹명과 그룹ID

- UNIX 시스템은 자원에 대한 접근 권한 및 보안 등의 관리를 위하여 사용자와 사용자가 소속된 그룹에 대한 식별이 필요하다.
- 사용자 ID와 그룹ID는 사용자와 그룹을 식별하는 식별자로 시스템에 유일한 정수 값으로 기술된다.

##### 기본 그룹과 보조 그룹

- UNIX 시스템은 자원의 소유자가 소속된 그룹에 별도의 권한을 지정할 수 있는데, 같은 그룹에 소속된 사용자는 자원에 대하여 동일한 접근 권한을 갖는다.
- UNIX 시스템의 사용자 계정은 하나의 기본 그룹과 복수의 보조그룹에 소속될 수 있다.
- 기본 그룹은 사용자가 자원(파일 등)생성 시 해당 자원의 소유그룹을 지정하는데 사용되며 /etc/passwd 의 4번째 필드 GID 값에 명시한다.

##### /etc/group 파일

- 현재 시스템에 정의된 모든 그룹의 정보를 저장하고 있다.

| group_name | unvariable                         | group_ID                                   | user_account_entry_in_group |
| ---------- | ---------------------------------- | ------------------------------------------ | --------------------------- |
| 그룹명     | 그룹의 암호화된 패스워드(사용안함) | 기본 그룹ID. 그룹명을 대신하는 정수형 숫자 | 소속된 사용자 계정들        |

### 입출력 재지정 (I/O Redirection)

- 입출력 대상으로 표준 입력, 표준 출력, 표준 예러를 사용하지 않고 다른 경로인 파일로 재지정 하는 것
- 키보드(표준입력:0) 에서 들어오는 입력을 파일에서 받도록 대체하는 것을 입력 재지정이라한다.

     ```sh
        $ command [0] < file_name
     ```

- 명령의 실행 결과나 에러 상황을 화면(표준출력:1, 표준에러:2)에 출력하지 않고 파일로 대체하는 것을 출력 재지정이라 한다.

     ```sh
        $ command [1 or 2] > file_name (미지정시 표준출력)

        >  # 출력 재지정(출력 파일 존재 시 새롭게 출력)
        >> # 출력 재지정(출력 파일 존재 시 추가하여 출력)
     ```

### ~~파이프(Pipe)~~

### ~~특수문자~~

# UNIX/Linux 파일 시스템

### 개요

- 물리적 저장장치에 파일 생성, 저장, 관리하기 위한 논리적인 자료구조를 파일시스템이라고 한다.
- 물리적인 디스크는 논리적인 파티션으로 나누어지며, 파티션 별로 고유한 파일 시스템을 생성한다.

##### 파일 시스템 구성

1. 부트블럭
   운영체제를 부팅하거나 초기화하기 위한 부트스트랩 코드를 담고 있는 블럭
2. 슈퍼블럭
   해당 파일시스템을 관리하기 위한 정보를 담고 있는 블럭
3. 아이노드 리스트

| 속성         | 설명                                                                                                                                                                                                                                                                      |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| inode number | 파일 시스템 내에서 해당 파일을 식별하기 위한 고유 식별자                                                                                                                                                                                                                  |
| 파일 타입    | 일반 파일, 디렉터리, 장치파일 등 파일 유형                                                                                                                                                                                                                                |
| 접근 권한    | 파일에 대한 접근권한                                                                                                                                                                                                                                                      |
| link count   | 해당 inode를 참조하는 링크 개수(하드링크 개수)                                                                                                                                                                                                                            |
| 소유자       | 파일의 소유자/UID                                                                                                                                                                                                                                                         |
| 소유그룹     | 파일의 소유그룹/GID                                                                                                                                                                                                                                                       |
| 파일크기     | 파일의 크기                                                                                                                                                                                                                                                               |
| MAC time     | last Access Time: 파일을 마지막으로 접근한 시간<br>last Modification Time: 파일의 내용을 마지막으로 수정한 시간<br>last Change Time:파일의 속성을 마지막으로 변경한 시간. 파일의 속성을 inode정보를 의미. 즉 소유자,접근권한 등의 속성이 변경되면 last Change Time이 변경 |
| Block Index  | Data blocks에 저장되어 있는 파일의 내용에 대한 색인 정보                                                                                                                                                                                                                  |

- 아이노드 리스트는 파일들에 대한 속성정보를 담고 있는 inode 구조체 리스트로 이루어져 있다.
- 각 파일의 속성정보는 위와 같다. 주의할 점은 inode에는 파일명이 없으며 파일 명은 디렉토리를 통해 관리된다.
- 침해 사고가 발생하면 피해 시스템에 대한 무결성을 확인하기 위해 타임라인을 분석을 수행한다. 이때 파일시스템 inode 구조체의 MAC Time 을 점검한다.
- 특정 파일의 inode에 대한 속성정보는 stat 명령을 통해 확인할 수 있다.

4. Data blocks

- 실제 파일의 내용(데이터)이 저장되는 블럭
- 고정 크기의 블럭들로 이루어져 있다.

### 파일 시스템과 링크 파일 `ln`

##### 개요

- 링크는 윈도우의 바로가기 아이콘 처럼 기존 파일에 대한 또 다른 접근 포인트를 만들어주는 기능이다.
- 링크는 하드 링크와 심볼릭 링크로 구분할 수 있다.

| 문법 | ln [-s] source_file or source_directory target_file                               |
| ---- | --------------------------------------------------------------------------------- |
| 옵션 | `-s` 이 옵션이 있으면 심볼릭 링크. 없으면 하드 링크                               |
| 설명 | 하드 링크는 파일에만 가능하고, 심볼릭 링크는 파일 또는 디렉토리에 링크할 수 있다. |

##### 하드 링크

- 하드 링크는 유닉스 초기 시절부터 지원해주던 방식으로 기존 파일과 동일한 inode number를 가지는 파일을 생성하여 접근하는 방식을 말한다.
- inode number는 파일 시스템 별로 고유한 값이기 때문에 동일한 파일 시스템 내에서만 하드 링크가 가능하고 디렉터리는 하드 링크가 불가능하다.
- 하드 링크 파일을 생성하면 해당 inode의 링크 카운트가 1 증가한다. 파일 삭제 시에는 링크 카운트를 1 감소시킨 후 그 값이 0이 되었을 때 해당 파일의 inode 정보 및 데이터가 삭제된다. 즉 inode를 참조하는 파일이 있으면 삭제하지 않는다.

##### 심볼릭 링크

- 동일한 파일 시스템 내에서만 링크가 가능한 하드 링크의 단점을 보완
- 원본 파일에 대한 파일 경로를 파일 내용으로 하는 새로운 파일을 생성해서 접근하는 방식으로 하드링크와 달리 inode number 가 아닌 파일 경로를 기반으로 하므로 파일시스템에 제한이 없으며 디렉터리도 가능하다.
- 원본 파일이 삭제되거나 이동하게되면 해당 경로가 바뀌므로 심볼릭 링크 파일은 링크가 끊어지게 된다.

### 디렉터리 관리

##### 파일의 종류

1. 일반파일
   일반적으로 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 되어 있다. 이러한 정규 파일은 표준 파일 입출력 시스템 호출을 통해 참조된다.
2. 디렉터리
   디렉터리에 포함된 파일명과 해당 파일에 대한 정보를 담고 있는 inode number 목록을 내용으로 가지고 있는 특수한 파일로 디렉터리 파일은 디렉터리의 명시적인 시스템 호출(ls)을 통해 참조된다.
3. 특수 파일
   특수 파일은 기능에 따라서 다양한 형태로 존재하며 표준 입출력 시스템 호출을 통해 참조된다.
      - 프로세스 간 통신(IPC)를 위해 파이프(pipe), 소켓(socket) 등의 파일을 사용한다.
      - 디스크, 프린터, 터미널, 키보드 등의 주변장치를 사용하기 위한 장치파일로 블럭 단위로 입출력하는 블록 장치파일(버퍼링)과 문자단위로 입출력하는 문자 장치파일(비 버퍼링)로 구분한다.

##### ls

- 파일의 종류

| 문자값 | 디렉터리 및 파일의 종류 |
| ------ | ----------------------- |
| d      | 디렉터리                |
| b      | 블록 장치 파일          |
| c      | 문자 장치 파일          |
| l      | 심볼릭 링크 파일        |
| p      | 네임드 파이프           |
| s      | 유닉스 도메인 소켓      |
| -      | 일반(정규) 파일         |

##### ~~cd~~

##### ~~mkdir~~

##### ~~rmdir~~

# UNIX/Linux 파일 관리

### ~~접근 권한 변경 `chmod`~~

### ~~소유주/소유그룹 변경 `chown`/`chgrp`)~~

### 접근 권한 마스크`umask`

- umask 명령은 앞으로 만들어질 파일에 영향을 미치는 명령으로, 명령 시 지정한 8진수는 새로 만들어질 파일에서 제거될 권한을 명시한다.
- 일반 파일을 생성할 때 접근권한은 666에서 umask 로 지정한 값을 빼고, 디렉터리의 경우 777에서 umask 로 지정한 값을 빼게 된다.
- 시스템 관리자는 /etc/profile 파일에 umask를 지정하여 시스템 전체 사용자에게 획일적인 umask 값을 적용할 수 있다.

### ~~UNIX/Linux 파일 검색 `find`~~

# UNIX/Linux 프로세스

### 프로세스 개요

- 프로세스가 생성되면 커널/운영체제는 개별 프로세스 관리정보를 담고 있는 프로세스 제어 블록(PCB: Process Control Block)을 생성
  - 프로세스 상태 (Process state): 프로세스의 현재 상태 정보를 저장(ready, running, blocked 등)
  - 프로세스 번호(Process number): 프로세스를 식별하기 위한 번호(ID)
  - 프로그램 카운터(Program counter): 문맥교환이 발생할 경우 다음에 실행할 명령어의 위치 값을 저장
  - 레지스터(Registers): 문맥교환이 발생한 경우 현재 프로세스의 실행 상태 정보(레지스터 정보)를 저장
  - 메모리 정보(Memory limits): 프로세스가 사용하는 메모리 page 또는 segment 테이블 정보

-  프로세스가 생성되면 개별 프로세스별로 오픈한 파일을 관리하기 위한 파일 디스크립터 테이블(FDT:File Descriptor Table)이 생성된다. 
   -  기본적으로 3개의 파일이 자동 오픈된다. 표준 입력(stdin)은 표준 입력장치로부터 입력을 의미하고, 표준출력(stdout)은 표준 출력장치(모니터)로의 출력을 의미하고, 표준에러(stderr)은 오류 발생시 출력을 의미한다. 
   -  프로세스 내에서 오픈한 각각의 파일을 식별하기 위한 양의 정수 값을 파일 디스크립터라고한다. 
- 커널/ 운영체제가 시스템 내에서 여러 프로세스에 의해 오픈된 파일들을 관리하기 위한 자료구조가 System open-file tables이다. 
  - open-mode: 파일의 읽기/쓰기 모드
  - offset: 현재 파일 I/O를 수행하기 위한 위치값(Position)
  - reference_count: 해당 파일의 참조 개수를 의미. 파일 복제(dup) 가 발생하게 되면  reference_count가 증가
- Active vnode table은 해당 파일의 inode 정보를 가지고 있는 일종의 캐시 역할을 한다. 즉, 다양한 파일시스템의 inode 정보를 관리하기 위한 중계자 역할을 한다. 

### 프로세스 기본 조건
* fork()  함수는 자식 프로세스를 생성하는 시스템 함수
* pid(프로세스 ID), ppid(부모 프로세스 ID) 
* 모든 프로세스는 부모 프로세스를 가진다. 
  * 시스템 부팅을 담당하는 boot 프로세스(0번 프로세스)를 제외한 모든 프로세스는 부모 프로세스를 가진다. 
  * 자식 프로세스가 살아있는 상태에서 부모 프로세스가 종료되면 자식 프로세스는 고아 프로세스가 되며, 이 경우 대리모 프로세스(pid가 1인 init process)가 부모 역할을 한다. 
* 프로세스 종료 시에는 자신의 종료상태정보를 부모 프로세스에 반환해야 정상적으로 소멸할 수 있다. 
  * 종료 상태 정보는 자신의 pid, exit code(종료시 반환하는 값), cpu time(cpu 사용시간) 등의 정보를 말한다. 
  * 프로세스 수행을 종료했지만 부모 프로세스가 종료 상태 정보를 확인하지 않아서 소멸하지 않고 남아 있는 상태의 프로세스를 좀비 프로세스라 한다. 시스템/커널 입장에서 프로세스는 제한된 자원이므로 좀비 프로세스가 과도하게 많아지면 더 이상 프로세스를 생성하지 못하는 문제가 발생할 수 있다. 

* ps -l 의 주요 필드의 의미는 다음과 같다. 
  
   | 필드명  | 설명|
   | ------ | ----------------------- |
   | F     | PROM(Programmable Read-Only Memory) 모드 |
   | S    | 프로세스의 현재 상태 <br> R: 프로세스가 실행중이거나 CPU를 점유하기 위해 대기 (Runnable/Ready) 중인 상태 <br>S: 인터럽트가 가능한 Sleep 상태<br>D: 인터럽트가 불가능한   Sleep 상태 (일반적으로 IO 대기 중 상태)<br>T: 프로세스가 정지된 상태(Stopped)<br>Z: 좀비    상태의 프로세스 (Zombie)|
   | PRI      | 프로세스의 우선순위(낮을수록 우선순위 높음)|
   | NI    | 프로세스의 우선순위를 계산할 때 사용하는 값 (Nice Value) |
   | ADDR     | 프로세스의 메모리 주소 |
   | SZ      | 프로세스가 차지하는 메모리 크기    |
   | WCHAN      | Sleeping 상태의 프로세스가 대기하는 커널 함수 명        |



### 프로그램 실행 과정
//// 그림 추가 필요

* 프로세스 생성과 동시에 프로세스 그룹도 생성된다. 
  * 프로세스 그룹은 커널이 터미널 제어권을 관리하기 위한 목적으로 사용하는 프로세스들의 집합으로 쉘에서 실행된 프로세스와 그 자식 프로세스들이 하나의 프로세스 그룹으로 관리된다. 
  * 터미널 제어권이랑 터미널로부터 입력되는 데이터와 터미널로부터 발생한 시그널에 대한 제어권으로 프로세스 그룹 단위로 제어권이 부여된다. 
  * 커널이 프로세스 그룹을 식별하기 위한 식별자로 PGID를 부여하며, PGID는 별도로 부여하는 식별자가 아니고 해당 그룹의 리더 프로세스(쉘로부터 실행된 프로세스)의 PID를 PGID 로 설정한다. 

<br>

* 포그라운드 백그라운드
  * 터미널에 대한 제어권을 가지고 동작하는 모드를 포그라운드 모드라고 하며, 제어권을 가지고 있는 프로세스 그룹을 포그라운드 프로세스 그룹이라 한다. 
  * 터미널에 대한 제어권 없이 동작하는 모드를 백그라운드 모드라고 하며, 제어권이 없는 프로세스 그룹을 백그라운드 프로세스 그룹이라 한다. 
  * 터미널과 연결되어 세션이 생성되면 해당 세션 내에서는 하나의 포그라운드 프로세스 그룹과 하나 이상의 백그라운드 프로세스 그룹이 생성된다. 

### 프로세스 관련 식별자
<!-- /// $ sleep 100 & 
/// ps -o pid,ppid,pgid,sid,cmd | grep -v ps 
/// 실행하고 첨부하기 -->

* Process ID(PID): 시스템/커널 내에서 프로세스를 식별하기 위한 고유 ID
* Parent Process ID(PPID): 부모 프로세스를 식별하기 위한 ID
* Process Group ID(PGID): 프로세스 그룹을 식별하기 위한 ID
  * 모든 프로세스는 생성과 동시에 하나의 프로세스 그룹에 속하게 되며, pgid는 해당 프로세스 그룹의 리더 프로세스의 pid가 된다. 
* Session ID(SID): 세션을 식별하기 위한 ID
  * 터미널과의 논리적인 연결 상태를 세션이라고 하며, 세션 내에는 다수의 프로세스 그룹과 프로세스 그룹에 속하는 프로세스들이 존재한다. 
  * sid는 해당 세션의 리더 프로세스(일반적으로 로그인 쉘) pid 가 된다. 


### 프로세스 정보 확인 `ps`
* 시스템에 상주하는 프로세스의 정보를 알려준다. 

   | 문법 | ps [-flaAe] [-G gid_list] [-g egid_list] [-U uid_list] [-u euid_list] [-t  terminal_list] |
   | ---- |------------------------------|
   | 옵션 | `-f` 이 옵션을 사용하면 프로세스 정보가 한줄씩 다음처럼 출력된다. <br> UserName PID    PPID C STIME TTY TIME CMD <br> `-l` 이 옵션은 `-f`옵션보다 더 많은 정보를 출력하며 다음과    같은 형식을 따른다. <br> F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD <br> `-a`   최근에 많이 실행된 제어 터미널을 가진 프로세스의 정보를 출력한다. <br> `-A,-e` 현재   시스템에서 실행 중인 모든 프로세스 정보를 출력한다. |
   | 예문 |  $ `ps -ef`  # 모든 프로세스를 보여주고, 다양한 정보를 한줄씩 출력 (가장 많이    사용됨)|


<br>

* ps -ef

|||
|----|----|
|UID|User ID, 프로세스의 EUID(Effective User Id)|
|PID|Process ID|
|PPID|Parent Process ID|
|C|프로세스 스케줄링을 위한 CPU 사용량|
|STIME|Start Time, 프로세스가 시작된 시간(월일시분초)|
|TTY|프로세스와 연결된 터미널 타입 `?`는 제어 터미널에 연결되어 있지 않음을 의미|
|TIME|CPU 사용 시간으로 "시:분" 형식으로 표현|
|CMD|프로세스 명|

<br>


### 프로세스간 통신(시그널)
* UNIX 시스템은 다양한 종류의 프로세스 간 통신 방법을 지원한다. (파이프, 시그널, 메시지큐, 공유메모리, 세마포어)
* 시그널은 UNIX 시스템에서 지원하는 소프트웨어 인터럽트다. 이를 이용하여 프로세스는 다른 프로세스에 이벤트를 전달할 수 있으며 전달된 이벤트를 프로세스 간 통신 수단으로 사용할 수 있다. 
* 시그널이 발생하는 경우는 외부에 의해서, 에러에 의해서, 이벤트에 의해서, 인위적으로  네 가지 이다. 
   |||
   |----|----|
   |에러상황|커널|
   |외부상황|키보드 입력|
   |이벤트 발생|alarm() 함수, 프로세스 종료|
   |인위적 발생|kill()함수 (System Call), kill 명령어|


   | 문법 | kill [-signal_number or -signal_name] PID <br> kill -l [signal]|
   | ---- |    --------------------------------------------------------------------------------- |
   | 옵션 | `-signal_number or -signal_name` 시그널 번호 또는 시그널 명(SIG 생략) <br> Us `-l` 지원 가능한 시그널 목록을 출력한다.|
   | 예문 |  $ `kill -9 3000`  <br> $ `kill -KILL 3000`|
   | 설명 |  시그널 옵션이 생략된 경우 SIGTERM 시그널이 발생한다.|
<br>

* 주요 시그널 UNIX/SunOS 기준
   |시그널 명|번호|의미|
   |----|----|---|
   |SIGNIT|2|`[Ctrl+c]` 조합키를 누르면 포그라운드 프로세스 그룹 내 모든 프로세스에게 이 시그널이 전달된다. 이 시그널을 받은 프로세스는 디폴트로 종료된다.|
   |SIGKILL|9|무시하거나 임의로 처리될수 없는 시그널로, 이 시그널을 받은 프로세스는 종료된다.|
   |SIGSTOP|23|프로세스를 정지시키는 프로세스 제어 시그널이며 무시하거나 임의로 처리할 수 없다.|
   |SIGTERM|15| 이 시그널을 받은 프로세스는 디폴트로 종료된다.|
   |SIGFPE|8|커널에 의해 발생한 산술연산에러(0으로 나누기 등)를 내느 프로세스에게 이 시그널이 전달된다.|
   |SIGCHLD|18| 프로세스의 종료나 정지의 경우 부모 프로세스에게 이 시그널이 전달된다.|
   |SIGALRM|14| alarm() 함수가 설전된 타이머에 의해 발생한다.|
   |SIGQUIT|3|`[Ctrl+\]`조합키를 누르면 전위 프로세스 그룹 내 모든 프로세스에게 이 시그널이 전달된다. 이 시그널을 받은 프로세스는 디폴트로 종료되며 Core 파일을 생성한다.|
   |SIGSEGV|11| 커널에 의해 발생하며 잘못된 메모리를 참조하는 프로세스에게 이 시그널이 전달된다.|
   |SIGHUP|1|터미널 연결이 끊어지는 경우에 프로세스에게 이 시그널이 전달된다. 최근에는 환경 설정 파일의 재설정에 사용된다.|
   
 <br>

# UNIX/Linux 시스템 관리

### 부팅 관련 용어 정리

##### 런 레벨

- 시스템의 런 레벨의 의미는 시스템의 운영 상태를 숫자 혹은 문자로 표현한 것이다.
- init 프로세스는 /etc/inittab 파일에 정의된 런 레벨에 따라 /etc/rc.d/rc[x].d(여기서 [x]는 런레벨) 디렉터리에 나열된 스크립트를 실행하여 시스템의 운영 상태를 구성한다.
- 각 런 레벨이 의미하는 시스템의 운영 상태는 일반적으로 다음과 같다.



| 런레벨  | 시스템의 운영 상태 |
| ------ | ----------------------- |
| 0      | PROM(Programmable Read-Only Memory) 모드 |
| S,s    | 시스템 싱글 유저 모드, 로컬 파일시스템이 마운트되지 않은 상태|
| 1      | 시스템 싱글 유저 모드, 로컬 파일시스템이 마운트된 상태|
| 2      | 멀티 유저 모드(NFS 클라이언트 모드)        |
| 3      | 멀티 유저 모드(NFS 서버 모드), UNIX 기본 Run Level  |
| 4      | 사용 안함      |
| 5      | 시스템 power off 모드         |
| 6      | 시스템 리부팅         |

- 서버용 UNIX 시스템은 일반적으로 3 또는 5의 런 레벨로 운영된다. 현재 운영 중인 시스템의 런 레벨을 알고 싶은 경우 who -r 또는 runlevel 명령을 사용한다. 


##### INIT 상태
- INIT 상태란 런 레벨과 같은 의미이다. 시스템이 런 레벨을 이동할 때, init 명령어를 통해서 이동한다. 
- 예를 들어 현재 런 레벨이 멀티 유저 모드인 3번인다. 싱글 유저 모드로 이동하고 싶으면 "init S" 명령어를 이용하면 된다. 
<br>

##### 시스템 런 레벨 단계 구성
// 추후 업데이트


### 시스템 시작

1. 바이오스 과정
   - 시스템 전원이 들어오면 바이오스는 시스템의 기본적인 하드웨어(CPU, 메모리 등)의 이상 유무를 점검하고 시스템의 하드웨어 정보를 수집한다. 
2. 부트 프로그램 과정
   - 부트 프로그램은 하드 디스크에서 커널을 읽어 들여 메모리 상에 적재하고 시스템 제어권을 커널에 넘긴다. 
3. 커널 과정
   - 커널이 메모리상에 적재되면 그때부터 운영체제가 구동되기 시작한다. 
   - 커널은 부팅 과정의 일부인 하드웨어 점검을 완료하고 내부 자료구조를 초기화하여 시스템을 운영하기 위한 부가적인 커널 모듈을 하드 디스크에서 메모리 상으로 적재한다. 
4. init 프로세스 과정
   -  init 프로세스는 커널에 의해 생성되는 첫번째 프로세스이다. 커널의 실행으로 운영체제가 하드웨어의 모든 기능을 제어하게 되었을 때 PID 가 1 인 init 프로세스가 실행된다. 
   -  이 프로세스는 모든 UNIX 프로세스의 부모 프로세스로서, 부팅 과정에서 사용자가 시스템을 사용할 수 있게 해주는 초기화 작업을 담당한다. 
   -  BSD 계열은 싱글 유저 모드와 멀티 유저 모드 두 가지를 지원하는 데 반하여, system V 계열은 더 많은 단계로 시스템의 운영 상태를 분류한다. 이를 런 레벨이라 한다. 

### 시스템 종료
- 운영 중인 UNIX 시스템은 정기 점검, H/W 및 S/W의 추가 또는 변경, 기타 관리 작업을 하기 위하여 시스템의 종료가 필요하다. 
- UNIX 시스템 종료 시 주의사항
   - 접속 중인 사용자에게 시스템의 종료를 공지하여 작업을 마무리하도록 해야한다. 
   - 운영 중인 서비스를 안전하게 종료해야 한다. 
   - 하드 디스크를 갱신하여 파일 시스템의 무결성을 유지한다. 

- shutdown 명령은 시스템을 안전하게 종료할 때 사용하며 시스템의 런레벨을 변경할 때도 사용한다. 이 명령은 System V 계열과 BSD 계열로 구분된다. 

- 하드디스크 동기화
  - UNIX 시스템은 하드 디스크의 입출력에 대한 효율성을 높이기 위해 버퍼를 운영한다. 
  - 만일 시스템이 비정상적으로 종료되면 버퍼에 있는 데이터가 하드 디스크에  반영되지 않아서 파일시스템에서 무결성 문제가 생긴다. 따라서 하드 디스크 동기화는 시스템을 종료하는 중에 해야 할 가장 중요한 작업이다. 
  - 유닉스나 리눅스 종료 시 sync 명령을 내리는 이유가 바로 버퍼의 내용을 하드 디스크로 옮기기 위함이다. 



### 사용자 관리

##### 사용자 계정 추가 `useradd`
* UNIX 시스템에 새로운 사용자 계정을 추가하는 과정은 다음과 같다. 
  -  사용자 계정 정보를 저장하는 "/etc/passwd"와 암호화된 비밀번호를 저장하는 "/etc/shadow"에 사용자 정보를 추가한다. 
  -  그룹 파일 "/etc/group"에 그룹 정보를 추가한다. 
  -  새 사용자를 위한 홈 디렉터리를 생성하고 접근권한을 부여한다. 
  -  사용자 로글인 시 필요한 몇 가지 시작 파일을 홈 디렉터리에 생성한다. 

##### 사용자 계정 삭제`userdel`

##### 그룹 추가`groupadd`
- 옵션: `-g gid`: 새로운 그룹에 할당할 그룹의 GID를 명시적으로 지정

##### 그룹 삭제`groupdel`

### 파일 시스템 관리

##### 파일시스템 연결 `mount`
* 보조기억장치에 들어 있는 데이터를 읽어오고, 여기에 저장하려면 먼저 해당 장치를 UNIX 시스템에 연결하는 작업이 필요하다. 
* mount 명령은 보조기억장치에 설치된 파일 시스템을 UNIX 시스템이 인식하도록 특정 디렉터리에 논리적으로 연결해준다. 
  
| 문법 | mount [-option] [device ! mount_point] <br> mount [-option] device  mount_point |
| ---- | --------------------------------------------------------------------------------- |
| 옵션 | `-a`  /etc/fstab 파일에 정의된 모든 파일시스템을 마운트 |
| 예문 | $ mount -a # /etc/fstab 파일을 기반으로 명시적으로 실행 <br> $mount /dev/cdrom /mnt/cdrom   #/dev/cdrom 디바이스 파일을 /mnt/cdrom 디렉터리에 마운트 |
| 설명 | 인수의 지정 없이 mount 명령만 사용하면 현재 시스템에 마운트된 정보를 출력한다. |

##### 파일시스템 연결 해제 `unmount`
* umount 명령은 이전에 마운트된 파일시스템의 연결을 해제한다. 
* 프로세스가 파일 시스템에 있는 파일을 사용중이거나 사용자가 파일시스템에 잇는 디텍터리에 있다면 umount 명령은 `device is busy` 메시지와 함께 실패한다. 
* /etc/mtab 파일은 시스템에 마운트된 파일시스템의 정보를 관리한다. mount 명령을 실행하면 파일 시스템이 마운트 정보를 /etc/mtab 파일에 기록하고, umount 명령은 정보를 삭제한다. 

| 문법 | unmount [-option] [device ! mount_point] |
| ---- | --------------------------------------------------------------------------------- |
| 옵션 | `-a`  마운트된 모든 파일시스템을 언마운트 <br> `-f`  해당 파일 시스템을 사용하는 프로세스를 강제로 종료하고 파일시스템을 언마운트 한다.|
| 예문 | $ unmount -a # 마운트된 모든 파일시스템을 언마운트한다. <br> $ unmount /mnt/cdrom  # /mnt/cdrom 디렉터리에 연결된 파일시스템의 연결을 끊는다. |
| 설명 | 언마운트 대상인 디바이스 파일 또는 마운트 포인트를 지정한다. 루트 디렉터리 / 는 언마운트 할 수 없다. |



##### 하드 디스크 사용량 `du`
* disk usage
* 디렉터리의 하드 디스크 사용량을 확인하는데 사용한다. 
| 문법 | du [-option] [derectory_name] |
| ---- | --------------------------------------------------------------------------------- |
| 옵션 | `-a`  디렉터리뿐만 아니라 하위의 파일에 대한 정보도 보여준다. All <br> `-s`  현재 디렉터리가 차지하는 총 용량만 출력한다. Summary <br> `-k`  사용량을 킬로바이트 단위로 환산하여 출력한다. |
| 설명 | derictory_name 인수를 사용하지 않으면 현재 디렉터리를 기준으로 한다. |


##### 파일 시스템 용량 정보 `df`
* disk free
* 파일 시스템의 전체 공간 및 사용 가능 공간에 대한 정보를 보여준다. 
  
| 문법 | df [-option] [file_system or file] |
| ---- | --------------------------------------------------------------------------------- |
| 옵션 |`-i`  파일시스템의 사용 가능한 또는 사용중인 inode 정보를 출력한다. <br> `-k`  통계 데이터를 1024Byte 블록 단위로 출력한다. |
| 설명 | file_system 인수는 파일 시스템이 있는 장치명 또는 파일 시스템이 마운트된 디렉터리를 의미한다. file 인수는 일반 파일 또는 디렉터리를 의미한다.  |


### 정기적 스케줄 관리 cron

##### cron
* cron 데몬 프로세스는 시스템에서 정기적인 작업을 지정시간에 처리하기 위해 사용한다. cron에 의해 동작하는 서비스를 주기적으로 확인하여 임의의 서비스가 동작하는 것을 예방해야 한다. 
* cron 데몬 프로세스를 통한 처리가 효율적인 작업은 다음과 같은 특징을 갖는다.  
  * 일괄적으로 처리해야하는 작업(특히 몰아서 하는 야간작업)
  * 작업에 대한 요구가 불규칙하지 않은 경우
  * 우선순위가 낮은 작업을 일정한 시기에 처리해야하는 경우
  * 작업 빈도가 낮아서 필요 시점에 처리하여 마무리하는 것이 자원 관리상 효율적인 경우
* cron 데몬 프로세스를 사용하려면 다음 세 가지 구성요소가 필요하다. 
  * 정기적으로 처리할 작업 목록을 정의한 crontab파일
  * crontab파일을 제어하는 crontab 명령
  * crontab 파일을 읽어서 내용에 정의된 대로 작업을 처리하는 cron 데몬 프로세스

* cron 데몬 프로세스는 시스템에서 기본적으로 지원하는 데몬 프로세스이므로 사요자는 crontab 명령으로 작업목록을 정의하는 방법만 이해하면 된다. 


<br>

##### crontab 파일의 구조

| 필드 | 의미 |기술방법 |
| ---- |---------|----|
| 필드1 | 분  | 0-59  |
| 필드2 | 시  | 0-23  |
| 필드3 | 일  | 1-31  |
| 필드4 | 월  | 1-12  |
| 필드5 | 요일  | 0-6 까지의 숫자로 기술, 일요일이 0  |
| 필드6 | 작업  | 지정한 시간에 실행할 작업을 절대 경로로 기술하고 <br>필요한 옵션 및 인수를 함께 나열한다.  |


* `*` 기호는 각 필드 범위에 해당하는 모든 값을 의미한다.
* `-` 기호는 값의 범위를 기술할 때 사용한다. 
* `,` 기호는 값을 구분하여 기술할 때 사용한다. 
* `/` 기호는 간격값을 지정할 때 사용한다. 

|예|설명|
|---|---|
|0 1 * * * batch.sh| 매일 01시에 batch.sh 실행|
|0 8-10 * * * batch.sh| 매일 8시, 9시, 10시에 batch.sh 실행|
|0 1,2,5 * * * batch.sh| 매일 1시,2시,5시에 batch.sh 실행|
|*/5 * * * * batch.sh| 매 5분 간격으로 batch.sh 실행|
|20 6 * * 1-5 /work/batch_job param1 | 매월 매일 월~금요일 오전 6시 20분에 /work/batch_job 명령을 param1 인수와 함께 실행|
|10 3 * * * /usr/sbin/logadm| 매일 새벽 3시 10분에 /usr/sbin/logadm 명령어 실행|


<br>

##### crontab 파일의 제어
* crontab 파일을 사용자 계정별로 만들어진다. 
* 시스템 관리자인 root 는 사용자를 명시적으로 지정하여 다른 사용자의 crontab 파일을 편집할 수 있으며, 일반 사용자는 자신의 crontab 파일만 편집할 수 있다. 

| 문법 | 리눅스: crontab [-u user] [-e] -l or -r  <br> 유닉스: crontab [-e] -l [-r] [user]|
| ---- | --------------------------------------------------------------------------------- |
| 옵션 |`-e`  crontab 파일을 편집한다.Edit <br> `-l` crontab 파일을  출력한다. List <br> `-r` crontab 파일을 삭제한다. Remove|
| 설명 | 사용자 계정을 명시하지 않으면 자신의 계정을 의미한다. |

<br>


##### crontab 명령 접근제어
* crontab 명령을 싱행할 수 있는 사용자를 제한하여 허용하지 않는 사용자가 임의로 crontab 명령을 통한 작업 등록을 못하도록 설정한다. 
* crontab 명령 접근 제어를 위해 /etc/cron.allow, /etc/cron.deny 설정 파일을 사용한다. 
* cron.allow 파일만 존재할 경우, 해당 파일에 등록되어 있는 사용자만이 crontab 명령을 실행할 수 있다. (화이트리스트 방식)
* cron.deny 파일만 존재할 경우 해당 파일에 명시된 사용자를 제외하고 모든 사용자가 crontab 명령을 실행할 수 있다. (블랙리스트 방식)
* cron.allow, cron.deny 파일이 모두 존재하는 경우 cron.allow 파일이 우선하여 해당 파일에 등록된 사용자만이 crontab 명령을 실행할 수 있다. 
* cron.allow, cron.deny 파일이 모두 없는 경우 대부분 시스템에서 root만이 crontab 명령을 실행할 수 있다. 일부시스템에서는 모든 사용자에게 실행 권한을 준다. 

<br>

### 일시적 스케줄 관리 `at`
* 작업을 정기적으로 스케줄링하는 cron 데몬 프로세스와 달리 at 명령은 정해진 시간에 한 번만 실행한다. 
* 작업은 예약 시간에 처리되고, 한번 처리된 작업은 작업 목록에서 삭제된다. 

| 문법 | at [-l] [-t] time_date|
| ---- | --------------------------------------------------------------------------------- |
| 옵션 |`-t time_date` 작업시간을 지정한다.(UNIX) <br> `-l` 현재 대기중인 작업 목록을  출력한다. List <br> `-r job_id` job_id 에 해당하는 작업을 목록에서 삭제한다. (UNIX) <br>  `-d job_id` job_id 에 해당하는 작업을 목록에서 삭제한다. (Linux)|
| 설명 | `atq`: at -l 과 같은 기능으로 작업목록을 출력한다. <br> atrm job_id: job_id에 해당하는 작업을 목록에서 삭제한다.| 

<br>

# UNIX/Linux 서버 시스템 보안

### 사용자 패스워드 관리

##### passwd

##### shadow

### 프로세스 실행 권한(SUID, SGID)

##### RUID, RGID. EUID, EGID

##### SUID, SGID

##### 특수 권한 비트

### 디렉터리 접근 권한(sticky-bit)

# UNIX/Linux 서버 네트워크 보안

### SSH

### 슈퍼 서버 [inetd 데몬]

##### 개요

##### inetd.conf 파일 구조

##### 불필요한/취약한 서비스 비활성화

### 접근통제[TCP Wrapper]

##### 개요

##### host.allow host.deny

#### xinetd 슈퍼데몬

##### 개요

##### 설정 파일 형식 (일반설정)

##### 설정 파일 형식 (접근제어 관련 설정)

##### 설정 파일 형식 (로그 관련 설정)

# PAM(장착형 인증 모듈 Pluggable Authentication Modules)

### 개요

### PAM을 사용한 인증 절차

### PAM 설정파일

### PAM 활용 예1

### PAM 활용 예2

### PAM 활용 예3

# 시스템 로그 설정과 관리

### 개요

### 유닉스/리눅스 주요 로그 파일

##### utmp(x) 로그 파일

##### wtmp(x) 로그 파일

##### lastlog 로그 파일

##### btmp(Linux),loginlog(Unix(SunOS)) 로그 파일

##### sulog 로그 파일 (Unix(SunOS))

##### acct/pacct 로그 파일 (Linux/Unix(SunOS))

##### histroy 로그 파일 (Linux/Unix(SunOS))

##### secure 로그 파일(Linux)

##### messages 로그 파일(Linux)

##### dmesg 로그 파일(Linux)

##### boot.log 로그 파일(Linux)

##### xferlog 로그 파일(Linux)

##### cron 로그 파일 (Linux)

##### maillog 로그 파일 (Linux)

### syslog 설정 및 관리

##### 개요

##### facility: 로그 생성 서비스

##### priority: 로그 수준

##### action

##### syslog.conf

### 리눅스 로그 관리

##### 로그 모니터링

##### 로그 파일 순환(rotate) 관리

# UNIX/Linux 서버 취약점

### UNIX/Linux 서버 계정 관리

1. root 이외의 UID가 0 금지

      - root(UID=0)와 동일한 UID를 가진 계정 존재 시 root 권한으로 시스템 접근이 가능하므로 root의 UID를 가진 계정이 존재하지 않도록 확인
      - root 이외의 계정이 UID=0 인 경우 0이 아닌 적절한 UID를 부여하거나 불필요한 계정일 경우 삭제

      | OS                          | 명령어                 |
      | --------------------------- | ---------------------- |
      | SOLARIS,<br>LINUX,<br>HP-UX | usermod -u 2023 ehdcjf |
      | AIX                         | chuser id=2023 ehdcjf  |

<br>

2. 패스워드 복잡성 설정
   _ 사용자 계정 암호를 유추하기 쉽게 설정하면 비인가자의 시스템 접근을 허용하게 하는 위험이 존재한다.
   _ 패스워드 관리 방법 1. 영문, 숫자, 특수문자를 조합하여 계정명과 상이한 8자 이상의 패스워드를 설정한다. 2. 영문 대문자, 영문 소문자, 숫자, 특수문자 중 2종류 이상을 조합하여 최소 10자리 이상 또는 3종류 이상을 조합하여 최소 8자리 이상의 길이로 구성한다. 3. 시스템마다 상이한 패스워드를 사용하고 패스워드를 기록할 경우에는 변형하여 기록한다. 4. 가급적이면 자주 패스워드를 변경한다.
   <br>

3. 패스워드 최소 길이 설정
      - 패스워드 무차별 공격이나 패스워드 추측 공격에 대응하기 위해 패스워드 최소 길이 설정이 필요하다. 최소 8자 이상.

<br>

4. 패스워드 최대 사용기간 설정
      - 패스워드 최대 사용기간을 설정하지 않으면 일정 기간 경과 후에도 유출된 패스워드로 접속할 수 있다.
      - 악의적인 사용자의 계속된 접속을 차단하기 위해 패스워드 최대 사용기간을 설정하여 주기적으로 변경할 수 있도록 한다.
      - 최대 사용 기간을 90일(12주)로 설정한다.

<br>

5. 패스워드 최소 사용기간 설정
      - 패스워드 최소 사용기간을 설정하지 않으면 사용자에게 익숙한 패스워드로 쉽게 변경할 수 있으며 이를 재사용함으로써 패스워드의 정기적 변경은 무의미해질 수 있다.
      - 패스워드 최소 사용기간을 1일(1주)로 설정한다.

<br>

6. 패스워드 파일 보호
      - 패스워드 정보를 평문으로 저장하는 경우 정보 유출 피해가 발생할 수 있으므로 패스워드를 암호화하여 보호해야한다.
      - shadow 패스워드를 사용하여 "/etc/shadow" 파일에 암호화된 패스워드가 저장되도록 하고 권한이 있는 사용자들만 읽을 수 있도록 제한한다.

<br>

7. Session Timeout 설정 \* 계정이 접속된 상태로 방치되면 권한이 없는 사용자에게 중요한 시스템이 노출되어 악의적인 목적으로 사용될 수 있으므로 일정 시간 이후 어떠한 이벤트가 발생하지 않으면 연결을 종료하는 Session Timeout 설정이 필요하다.
   <br>

### 파일 및 디렉터리 관리

1. root HOME, PATH 디렉터리 권한 및 PATH 설정
   _ root 계정의 PATH 환경변수에 "."이 포함되어 있으면 root 계정으로 접속한 관리자가 의도하지 않은 현재 디렉터리에 위치하고 있는 명령어가 실행될 수 있다. 즉 "."이 /usr/bin, /sbin 등의 명령어들이 위치하고 있는 디렉터리보다 우선하여 위치하고 있을 경우, root 계정으로 접속한 관리자가 특정 명령을 실행하면 불법적으로 현재 디렉터리에 위치시킨 파일을 실행하여 예기치 않은 결과를 가져올 수 있다.
   _ PATH 환경 변수에 "."이 맨 앞 또는 중간에 위치하고 있으면 root 가 의도하지 않은 명령이 실행될 수 있으므로 PATH 환경변수의 마지막으로 이동시키거나 불필요한 경우 삭제한다.
   <br>

2. 파일 및 디렉터리 소유자/소유그룹 설정

      - 소유자/소유그룹이 존재하지 않는 파일 및 디렉터리는 현재 없는 소유자/소유그룹의 소유였거나, 관리 소홀로 인해 생긴 파일일 가능성이 있다.
      - 사용하지 않는 디렉터리나 파일일 경우 시스템 자원 낭비가 될 수 있고 중요한 파일 및 디렉터리일 경우 관리가 되지 않는 문제가 있다.
      - find 명령의 -nouser -nogroup 옵션을 통해 소유자/소유자그룹이 존재하지 않는 파일/디렉터리를 검색

      ```sh
          $ find .\( -nouser -o -nogroup \) -exec ls -al {} \;
      ```

      - 파일 소유자/소유그룹 변경 또는 불필요 시 삭제
        chown 또는 chgrp 명령을 통해 소유자/소유그룹을 변경한다.

3. world writable 파일 점검
   _ "world writable" 파일이란 모든 사용자(others)에게 쓰기 권한이 부여된 파일을 말한다.
   _ 모든 사용자가 접근 및 수정할 수 있는 권한으로 설정된 파일이 존재하면 일반 사용자의 실수 또는 악의적으로 주요 파일 정보를 변경할 수 있으므로 시스템 장애나 추가적인 공격에 활용될 수 있는 문제가 있다. \* find 명령의 "-perm -2" 옵션을 통해 others에 쓰기(w) 권한이 부여된 파일/디렉터리를 검색, others에 대한 쓰기 권한을 제거하거나 불필요한 파일/디렉터리인 경우 삭제
   ```sh # 검색
   $ find /home/ehdcjf -perm -2 -exec ls -al {} \;

              $ find /home/ehdcjf -perm -0002 -exec ls -al {} \;

              # 권한 제거
              $ chmod o-w /home/ehdcjf/sample.config

              # 파일 삭제
              $ rm -rf /home/ehdcjf/sample.config

          ```

      <br>

4. 주요 파일 소유자 및 권한 설정
      - /etc/passwd : 사용자 정보를 담고 있는 파일로 root 소유의 644 이하의 권한 설정
      - /etc/shadow : 사용자의 암호화된 패스워드 정보를 담고 있는 파일로 root 이외에는 접근 못하도록 root 소유의 400 이하의 권한을 설정
      - /etc/host : IP와 호스트 이름을 매핑하는데 사요되는 파일로 외부의 불법적인 접근에 의한 조작 시 악의적인 시스템에 접근할 가능성이 있으므로 root 소유의 600 이하의 권한을 설정한다.
      - /etc/(x)inetd.conf : inetd 데몬에 대한 설정파일로 외부의 불법적인 접근에 의해 악의적인 프로그램을 등록하고 root 권한으로 실행할 가능성이 있으므로 root 소유의 600 이하의 권한을 설정한다.
      - /etc/syslog.conf : syslogd 데몬에 대한 설정파일로 주요 로그파일에 대한 설정 정보를 가지고 있다. 해당 파일의 접근권한이 적절하지 않아 외부의 불법적인 접근에 의하여 변경되는 경우 시스템 로그가 정상적으로 기록되지 않아 외부의 불법적인 접근에 의해 변경되는 경우 시스템 로그가 정상적으로 기록되지 않아 침입자의 흔적 또는 시스템 오류 사항을 정확히 분석할 수 없으므로 root 이외의 사용자는 해당 파일을 변경할 수 없도록 root 소유의 644 이하의 권한을 설정한다.
      - /etc/services : 서비스 관리(서비스별 포트/프로토콜 정보)정보를 담고 있는 파일로 접근 권한이 적절하지 않아 외부의 불법적인 접근에 의해 변경되는 경우 정상적인 서비스를 제한하거나 허용되지 않는 서비스를 등록하는 등의 위험이 있으므로 root 소유의 644 이하의 권한을 설정한다.
