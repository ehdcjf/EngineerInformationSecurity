# 윈도우 서버 보안

### 윈도우 인증과정
1. 윈도우 인증과정에서 사용되는 주요 서비스에는 LSA(Local Security Authority), SAM(Security Account Manager), SRM(Security Reference Monitor) 등이 있다. 
2. LSA
    * 모든 계정의 로그인에 대한 검증 및 시스템 자원(파일 등)에 대한 접근 권한을 검사한다.(로컬 및 원격 로그인 포함)
    * 계정명과 SID(Security ID)를 매칭하며 SRM이 생성한 감사 로그를 기록한다. 
    * NT 보안의 중심 서비스이며 보안 서브시스템이라 불린다. 

3. SAM 
    * 사용자/그룹 계정 정보에 대한 데이터베이스 관리
    * 사용자 로그인 정보와 SAM 파일에 저장된 사용자 패스워드 정보를 비교해 인증 여부를 결정
    * SAM 파일은 사용자, 그룹 계정 및 암호화된 패스워드 정보를 저장하고 있는 데이터 베이스로 윈도우 설치 디렉터리에 있다. 

4. SRM
    * 인증된 사용자에게 SID를 부여
    * SID를 기반으로 하여 파일이나 디렉터리에 대한 접근을 허용할지 여부를 결정하고 이에 대한 감사 메시지를 생성

### 로컬 인증 
윈도우 부팅 후 로그인 창에서 아이디와 패스워드를 입력하면 LSA 서브시스템이 인증정보를 받아 NTLM 모듈에 넘기고 이를 다시 SAM이 받아 로그인을 처리한다. 

### 원격(도메인) 인증
1. 윈도우 부팅 후 로그인창에서 아이디와 패스워드를 입력하면 LSA 서브시스템 인증 정보를 받아 로컬 인증용인지 도메인 인증용인지 확인하고 커버로스(Kerberos) 프로토콜을 이용해 도메인 컨트롤러에 인증을 요청한다. 
2. 도메인 컨트롤러는 인증 정보를 확인하여 접속하고자 하는 사용자에게 접근 토큰을 부여하고 해당 권한으로 프로세스를 실행한다. 

### SAM 파일 접근 통제 설정
1. SAM 파일은 사용자와 그룹 계정의 패스워드를 관리하고 LSA를 통한 인증을 제공하는 중요한 파일이므로 적절한 접근 통제가 필요하다. 
2. 공격자로부터 SAM 파일에 대한 패스워드 공격 시도에 따른 정보 노출의 위험이 있다.
3. 보안 설정
    __system32 > config > SAM__
    * SAM의 사용 권한에서  Administrators 및 System 그룹 이외에는 SAM 파일에 대한 접근을 제한한다. 
    * 불필요한 그룹 및 계정에 대해서는 권한을 제거한다. (Everyone)

### 윈도우 보안 식별자(SID:Security Identifier)
* 윈도우의 각 사용자나 그룹에 부여되는 고유한 식별번호
* 사용자가 로그인을 수행하면 접근 토큰(엑세스 토큰)이 생성되며, 해당 토큰에는 로그인한 사용자와 그 사용자가 속한 모든 작업 그룹들에 관한 보안 식별자(SID) 정보가 담겨있다. 
* 접근 토큰의 사본은 그 사용자에 의해 시작된 모든 프로세스에 할당된다. 
* 사용자 계정 및 패스워드 정보를 담고 있는 SAM 파일(c:\windows\system32\config)에 SID 정보가 저장되어 있다. 

#### SID 구조
|계정|SID|
|------|---|
|Administrator|S-1-5-21-4243233100-3174512425-4165118588-500|
|Guest|S-1-5-21-4243233100-3174512425-4165118588-501|
|일반 사용자 |S-1-5-21-4243233100-3174512425-4165118588-1001|

* S-1: 윈도우 시스템을 의미
* 5-21: 시스템이 도메인 컨트롤러이거나 단독 시스템임을 의미
* 4243233100-3174512425-4165118588: 해당 시스템만의 고유한 식별자. 동일한 컴퓨터에 다시 윈도우를 설치해도 동일한 값을 가지지 않는다. 
* 500,501,1000이상
    500: 관리자 식별자
    501: 게스트 식별자
    1000 이상: 일반 사용자 식별자

* 실행 > wmic > __useraccount list brief__ 명령 실행

### 윈도우 인증 구조
|사용자||윈도우|
|------|---|---|
|인증요청|>>||
|||Challenge 값 생성|
||<<|Challenge 값 전송|
|Response 값 생성|||
|Response 값 전송|>>||
|||Response 값 확인|
||<<|인증성공|

* 단순히 아이디워 패스워드를 전달하여 인증하는 방식은 정보 노출 및 패스워드 재사용 공격에 매우 취약하므로 운영체제 인증과 같은 높은 수준의 인증이 필요한 경우에는 적절하지 않다. 
* 윈도우에서는 Challenge & Response 방식의 인증 구조를 사용한다. 단계별 동작 방식은 다음과 같다. 
    1. 인증요청: 인증하고자 하는 사용자가 윈도우 시스템에 인증 요청한다. 
    2. Challenge 값 생성: 인증요청을 받은 서버는 특정한 규칙 또는 랜덤한 Challenge 값을 생성하여 사용자에게 전달한다. 
    3. Response 값 생성 및 전송: 사용자는 전달받은 Challenge 값과 사용자 패스워드 정보를 이용해 Response 값을 생성하여 서버에 전달한다. 
    4. Response 값 확인 및 인증 성공: 사용자가 전달한 Response 값을 확인하여 인증 성공 여부를 전달한다. 

#### 인증 암호 알고리즘
1. LM(Lan Manager) 해시: 윈도우 2000, XP의 기본 알고리즘으로 구조적으로 취약. 윈도우 비스타 이후 버전부터는 LM을 기본적으로 사용할 수 없게 함. 
2. NTLM 해시: LM 해시에 MD4 해시가 추가된 형태
3. NTLMv2 해시: 윈도우 비스타 이후 윈도우 시스템의 기본 인증 프로토콜로 기존 인증 알고리즘과는 전혀 다른 알고리즘으로 해시값을 생성하며 현재까지 복잡도가 충분해 크래킹이 어렵다. 

#### Lan Manager 인증 수준
1. Lan Manager 는 네트워크를 통한 파일 및 프린터 공유 등과 같은 작업 시 인증을 담담하는 서비스이다. 
2. Lan Manager 인증 수준 설정을 통해 네트워크 로그온에 사용할 Challenge/Response 인증 프로토콜을 결정하면, 이 설정은 클라이언트가 사용하는 인증 프로토콜 수준, 협상된 세션 보안 수준 및 서버가 사용하는 인증 수준에 영향을 주기 때문에 보다 안전한 인증을 위해 NTLMv2 사용을 권장한다. 


# 윈도우 서버 취약점

### 윈도우 서버 계정 관리

1. Administrator 계정 이름 변경
   * 관리자 계정은 컴퓨터 전체에 대한 모든 권한을 가진 계정이므로 특별한 관리가 필요. 
   * 기본 관리자 계정명인 Administrator를 그대로 사용할 경우 악의적인 공격자에 의한 패스워드 무차별 공격에 취약할 수 있다. 따라서 쉽게 유추하기 어려운 관리자 계정명으로 변경하는 것을 권장한다. 
   * 윈도우 관리자 계정의 경우 로그온 실패 횟수에 제한이 없는 특징이 있다. 
   * 계정명 확인
        > 제어판 > 관리도구 > 컴퓨터 관리 > 로컬 사용자 및 그룹 > 사용자에서 계정명 확인
   * 계정명 변경
        > 제어판 > 관리도구 > 로컬보안정책 > 로컬정책 > 보안옵션의 "계정: Administrator 계정 이름 바꾸기" 를 통해 관리자 계정명 변경
2. Guest 사용 제한. 
   * Guest 계정은 소프트웨어나 하드웨어 설치, 설정 변경, 암호 만들기 등을 할 수 없고 외부 사용자가 컴퓨터를 잠시 접근할 수 있는 계정이다. 
   * Guest 계정은 불특정 사용자의 시스템 접근을 허용하는 취약한 계정으로 사용 제한을 권장하며 불특정 다수의 접근이 필요한 경우 Guest 계정이 아닌 일반 사용자 계정을 생성해 사용하도록 해야한다. 
   * Guest 계정 사용 제한
        > 제어판 > 관리도구 > 컴퓨터 관리 > 로컬 사용자 및 그룹 > 사용자에서 Guest 계정 선택 후 "계정 사용 안 함" 적용

3. 불필요한 계정 제거
   * 불필요한 계정, 의심스러운 계정, 장기간 사용하지 않는 계정은 계정 정보 유출의 위험성이 있으므로 삭제 또는 계정 잠금 설정한다. 
        > 시작 > 프로그램 > 제어판 > 관리도구 > 컴퓨터 관리 > 로컬 사용자 및 그룹 > 사용자에서 불필요한 계정에 대한 삭제 또는 계정 사용 안 함 선택

4. 관리자 그룹에 최소한의 사용자 포함
   * 관리 업무를 수행하는 계정과 일반 업무를 수행하는 계정은 분리하여 사용하는 것이 바람직하며 관리자 그룹에는 최소한의 계정만을 포함
   * 관리자 그룹에 불필요한 계정이 있다면 해당 계정을 제거
  
5. 암호/패스워드 정책 설정
    * 패스워드 복잡성 설정
      - 패스워드 설정 시 영문자(대소)/숫자/특수문자를 모두 포함하여 보안적으로 안전한 패스워드를 만들어야한다. 
      - 윈도우 운영체제의 복잡성 기준
        > 영문 대문자, 영문 소문자, 숫자, 특수문자 중에서 2가지 종류를 조합했을 경우 최소 10자리 이상, 3가지 이상 종류를 조합했을 경우 8자리 이상의 길이가 되어야 한다. 
    * 최근 패스워드 기억 설정
        * 사용자가 최근에 사용했던 패스워드를 동일하게 사용할 수 없도록 설정한다. 
        * 최근 암호 기억을 12개 이상으로 권장
    * 패스워드 최대 사용기간 설정
        * 복잡한 패스워드를 설정한다고 해도 공격자가 무차별 공격으로 추정 가능한 암호에 대해서 크랙을 시도한다면 결국 이를 알아낼 수 있다. 따라서 주기적으로 패스워드를 변경하여 위험성을 줄여야한다. 
        * 최대 암호 사용기간(패스워드 만료 기간 90일 이하 권장)
        * 계정 속정의 "암호 사용 기간 제한 없음"을 해제 
    * 패스워드 최소 사용 기간 설정
      * 패스워드 변경에 시간적 제약이 없다면 "최근 패스워드 기억 설정"을 무력화하여 이전에 즐겨 사용하던 패스워드를 다시 사용할 수 있다. 따라서 최소 사용기간을 설정하여 해당 기간에는 패스워드를 변경하지 못하도록 설정한다. 
      * 최소 암호 사용 기간을 0보다 큰 값으로 설정(일반적으로 1일 설정)
    * 패스워드 최소 길이 설정
      * 적절한 길이의 패스워드로 설정하여 보안상 안전하고 사용자가 쉽게 기억할 수 있는 패스워드를 만들어야한다. 최소 암호길이 8자 이상 권장. 
    * 해독 가능한 암호화 사용 설정
      * 해독 가능한 암호 방식으로 저장할 경우 공격자의 암호 공격에 노출될 수 있다. 따라서 반드시 필요한 경우(다른 응용 프로그램에 의해 사용)를 제외하고는 "사용 안 함" 설정한다. 
6. 계정 잠금 정책
    * 계정 잠금 기간
      * 계정 잠금 기간을 설정하면 패스워드 틀린 횟수가 계정 잠금 임계값에 도달했을 때 지정한 기간(시간)동안 계정을 잠근다. 따라서 공격자의 무차별 공격에 효과적으로 대응할 수 있다. 
      * 계정 잠금 기간을 60분 이상으로 설정 권장
    * 계정 잠금 임계값 
      * 자동화된 방법을 통해 공격자는 패스워드에 대하여 무차별 공격을 시도할 수 있으므로 로글온 실패 횟수에 대한 제한이 필요한다. 계정 잠금 임계 값은 5 이하의 값이 권장 된다. (Administrator 계정은 잠기지 않는다)
    * 다음 시간 후 계정 잠금 수를 원래대로 설정
      * 실패한 로그온 시도 후 실패한 로그온 시도 카운트가 0으로 설정될 때까지 경과해야하는 시간을 지정한다. 60분 이상 설정 권장. 

### 윈도우 서버 서비스 관리
1. 하드디스크 기본 공유 제거
   * Windows는 프로그램 및 서비스를 네트워크나 컴퓨터 환경에서 관리하기 위해 시스템 기본 공유 항목을 자동으로 생성한다. 
      * 하드디스크 기본 공유 : C$ , D$
      * 원격 관리 및 IPC용 기본 공유: ADMIN$, IPC$ 
   * 하드디스크 기본 공유인 C$,D$ 등을 제거하지 않으면 기본 공유 폴더를 통해 인가받지 않은 사용자가 하드디스크 내의 폴더나 파일에 접근하거나 바이러스가 침투하는 경로가 될 수 있다.  
```
    net share C$ /delete

    net share D$ /delete    
```

   * 단 기본 공유의 경우. 공유 중지를 해도 운영체제가 재시작 되면 다시 생성되기 때문에 레지스트리 수정이 필요하다. 

2. 공유 권한 및 사용자 그룹 설정
   * 공유 폴더에 Everyone 그룹이 포합되어 있으면 익명 사용자에 의한 접근이 가능하므로 Everyone 그룹을 제거하도록 한다. 

3. 불필요한 서비스 제거
   * 취약한 서비스들이 디폴트로 설치되어 실행되고 있으면 이러한 서비스 또는 응용프로그램은 공격 지점이 될 수 있으므로 사용자 환경에서 필요하지 않은 서비스나 실행파일을 사요하지 않거나 제거한다. 
   * 주요 취약 서비스는 다음과 같다. 
        - Alerter: 서버에서 클라이언트로 경고 메세지를 보냄
        - Clipbook: 서버 내 Clipbook을 다른 클라이언트와 공유
        - Messenger: net send 명령어를 이요하여 클라이언트에게 메시지 보냄
        - Simple TCP/IP Services(Echo, Discard, Character Generator, Daytime, Quote of the Day)

### 윈도우 서버 로그관리
1. 감사 정책 설정
    * 윈도우 운영체제에서 말하는 감사 정책은 어떤 로그를 남길지를 정의한 규칙을 말한다. 감사 정책을 설정하게 되면 감사 정책에 의해 지정한 이벤트에 대해서만 로그가 남는다. 
    * 감사 설정이 구성되어 있지 않거나 감사 설정 수준이 너무 낮으면 보안 관련 문제 발생 시 원인을 파악하기 어려우며 법적 대응을 위한 증거로 사용될 수도 없다. 
    * 감사 설정이 너무 높으면 보안 로그에 불필요한 항복이 많이 기록되므로 매우 중요한 항목과 혼동할 수 있으며 시스템 성능에도 심각한 영향을 줄 수 있기 때문에 법적 요구 사항과 조직의 정책에 따라 필요한 로그를 남기도록 설정한다. 
  
2. 감사 항목
   
|감사항목|권장값|설명|
|--------|-----|---|
|개체 엑세스|감사 안함| 파일, 디렉토리, 레지스트리, 프린터 등의 객체에 대한 접근 성공/실패 여부를 기록할지 결정|
|계정 관리|실패| 계정 관리 이벤트를 감사할지 여부를 결정 <br> 사용자 계정 또는 그룹의 생성, 변경, 삭제, 암호의 설정 및 변경 등의 이벤트 성공/실패 로그를 기록|
|계정 로그온 이벤트|성공, 실패| 도메인 계정에 대한 로그온 성공/실패 관련 이벤트 로그를 기록할지를 결정|
|권한 사용|실패|권한 사용의 성공 및 실패를 감사할 경우 사용자 권한을 이용하려고 할 때마다 이벤트 생성|
|디렉터리 서비스 액세스|실패|Active Directory 개체의 시스템 액세스 컨트롤 목록(SACL)에 나열된 사용자가 해당 개체에 액세스를 시도할 때 이벤트 생성|
|로그온 이벤트|성공, 실패| 로컬 계정에 대한 로그온/오프 성공/실패에 대한 이벤트를 기록할지를 결정|
|시스템 이벤트|감사 안함|시스템 시작 또는 종료, 보안 로그에 영향을 미치는 이벤트등을 감사할지 여부를 결정|
|정책 변경|성공, 실패|감사 정책 변경의 성공 및 실패를 감사|
|프로세스 추적|감사 안함|실행되는 프로세스에 대한 자세한 추적정보를 감사하는 경우 프로세스 생성, 프로세스 종료, 핸들 복제 및 간접 개체 액세스 같은 프로세스 관련 이벤트를 감사할지 여부를 결정|


   
    
# UNIX/Linux 서버 보안
















# 시스템 해킹

### 패스워드 크래킹

1. 사전 공격/사전 대입 공격(Dictionary Attack)
    패스워드로 자주 사용되는 사전에 있는 단어 + 키보드 자판의 일련 순서(e.g. asdf qwer1234 등) + 주민등록번호, 이름 등을 미리 사전 파일로 만든 후 이를 하나씩 대입하여 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법 
    <br>
2. 무차별 공격/무작위 대입 공격(Brute Force Attack)
    패스워드에 사용될 수 있는 문자열의 범위를 정하고, 그 범위 내에서 생성 가능한 모든 패스워드를 생성하여 이를 하나씩 대입, 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법.
    일반적으로 사전 대입 공격 실패 후 무차별 공격을 진행한다. 
    <br>
3. 혼합공격(Hybrid Attack)
    사전 공격과 무자별 공격을 혼합한 방식으로 사전 파일에 있는 문자열에 문자, 숫자 등을 추가로 무작위 대입하여 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법.
    일반적으로 사전 파일에 나오는 문자열 뒤에 숫자나 문자를 추가하는 형태의 패스워드가 많이 사용되는 점을 악용
    <br>
4.  레인보우 테이블을 이용한 공격
    레인보우 테이블은 하나의 패스워드에서 시작해 특정한 변이 함수를 이요해 여러가지 변이된 형태의 패스워드를 생성한다. 그리고 각 변이된 패스워드의 해시를 고리처럼 연결하여 일정 수의 패스워드와 해시로 이루어진 체인을 무수히 만들어 놓은 테이블이다. 
    해시 테이블과 R(Reduction) 함수의 반복 수행을 통해 일치하는 해시값을 통해서 패스워드를 찾아내는 방식이다. 

### 버퍼 오버 플로우 공격
 * 버퍼 오버플로우는 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에 자료를 읽거나 쓰려고 할 때 발생한다. 버퍼 오버플로우가 발생하게 되면 프로그램의 오작동을 유발시키거나, 악의적인 코드를 실행시킴으로써 공격자가 프로그램을 통제할 수 있는 권한을 획득하게 된다. 
<br>

##### 스택 오버 플로우
스택은 함수 처리를 위해 지역 변수 및 매개변수가 위치하는 메모리 영역을 말한다. 스택에 할당된 버퍼들이 문자열 계산등에 의해 정의된 버퍼의 한계치를 넘은 경우 버퍼 오버플로우가 발생하여 복귀 주소(Return Address)를 변경하고 공격자가 원하는 임의의 코드를 실행한다.
    

##### 힙 오버 플로우 
힙은 사용자가 동적으로 할당하는 메모리 영역(malloc()등의 메모리 할당 함수 이용)이다. 힙에 할당된 버퍼들에 문자열 등이 저장될 때, 최초 정의된 힙의 메모리 사이즈를 초과하면 문자열 등이 저장되는 경우 버퍼 오버플로우가 발생하여 데이터와 함수 주소등을 변경하여 공격자가 원하는 임의의 코드를 실행한다. 


##### 버퍼 오버플로우 이해를 위한 C 언어 함수
* __strcpy(char *dst, const char *src)__
src 문자열을 dst 버퍼에 저장한다. src 문자열의 길이를 체크하지 않으므로 dst 버퍼를 초과하는(오버플로우) 결과가 발생할 수 있다.
<br>

* __strncpy(char *dst, const char *src, size_t len)__
src문자열의 len 만큼을 dst버퍼에 저장한다. src 문자열의 길이를 제한하기 때문에 버퍼 오버플로우에서 안전하다. 
<br>

* __size_t strlen(const char *str)__
문자열(str)의 null 문자를 제외한 바이트 수를 반환한다. 
<br>

* __sizeif(피연산자)__
피연산자의 크기를 반환한다. 
<br>


##### 스택 버퍼 오버플로우 대응방안
1. 안전한 함수를 사용하여 버퍼 오버플로우 방지
2. 입력값 사전 검증을 통한 버퍼 오버플로우 방지
<br>

##### 스택 버퍼 오버플로우 대응기술

1. __스택가드__:
메모리 상에서 프로그램의 복귀주소(Return Address)와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우를 오버플로우로 가정하여 프로그램 실행을 중단하는 기술을 말한다. 
2. __스택 실드__:
함수 시작 시 복귀 주소(Return Address)를 Global RET라는 특수 스택에 저장해 두었다가 함수 종료 시 저장된 값과 스택의 RET값을 비교해 다를 경우 오버플로우로 가정하여 프로그램 실행을 중단시키는 기술을 말한다. 
3. __ASLR__(Address Space Layout Randomization):
메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하는 기법이다. 실행 시마다 메모리 주소를 변경시켜 악성 코드에 의한 특정 주소 호출을 방지한다. 
<br>

### 레이스 컨디션 공격
* 레이스 컨디션은 둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 점근하는 순서에 따라 비정상적인(원하지 않는) 결과가 발생하는 조건/상황을 말한다. 
* 실행되는 프로세스가 임시 파일을 만드는 경우 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 특정파일로 연결(심볼릭 링크)하여 악의적인 행위를 할 수 있는데 이를 레이스 컨디션 공격이라고 한다. 
* 만약 프로세스가 setuid 설정이 되어 root 권한으로 실행된다면 권한 상승을 통해 중요자원(파일)에 접근하는 심각한 문제가 발생할 수 있다. 

##### 레이스 컨디션 대응방안
1. 가능하면 임시 파일을 생성하지 않는다. 
2. 파일 생성 시 이미 동일한 파일이 존재하는 경우 파일 생성 또는 쓰기를 금지한다. 
3. 사용하고자하는 파일에 링크가 걸려있으면 실행을 중단한다. 
4. umask를 최하 022정도로 유지하여 임시로 생성한 파일이 공격자에 의해 악의적으로 삭제되지 않도록 한다. 


### 포멧 스트링 공격
* 포멧 스트링은 C 언어의 printf()등의 함수에서 사용되는 문자열의 입출력 형태를 정의하는 문자열로 서식 문자열이라 표현한다. 
* 포멧 스트링을 인자로 하는 함수의 취약점을 이용한 공격으로 외부로부터 입력된 값을 검증하지 않고 입출력 함수의 포멧 스트링을 그대로 사용하는 경우 발생할 수 있는 취약점이다. 
* 공격자는 포멧 스트링을 이용하여 취약한 프로세스를 공격하거나 메모리 내용을 읽거나 쓸 수 있다. 그 결과, 공격자는 취약한 프로세스의 권한을 획득하여 임의의 코드를 실행할 수 있다. 

##### 포멧 스트링의 취약점
* 포멧 스트링을 인자로 하는 함수 사용시 포맷 스트링을 지정하지 않고 사용자의 입력을 통해서 포맷스트링이 결정된다면 공격자는 이를 조작하여 메모리 내용을 참조하고 특정 영역의 값을 변경할 수 있다. 
* 가령, 공격자는 스택 프레임 구조를 고려하면서 "%x"를 통해 메모리 내용을 참조 및 원하는 위치(RET 영역)로 이동한 후 "%n"을 통해 Return Address를 악성코드가 위치한 주소로 변조하여 악성 코드를 실행할 수 있다. 

##### 포멧스트링 대응방안
포멧 스트링을 함수의 입력 파라미터로 직접 사용하지 않는다. 
* 취약한 사용의 예
```c
#include <stdio.h>
int main(int argc, char **argv){
    printf(argv[1]);
}
```

* 안전한 사용의 예
```c
#include <stdio.h>
int main(int argc, char **argv){
    printf("%s", argv[1]);
}
```
포멧 스트링을 지정하여 간접적으로 참조가 되도록 한다. 


  


