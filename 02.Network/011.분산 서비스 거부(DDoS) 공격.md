# 분산 서비스 거부 (DDoS: Distributed Denial of Service) 공격
<!-- DDoS 공격 구조 이미지 -->
* 분산 서비스 거부 공격은 분산된 다수의 좀비PC/디바이스에 의해 공격 대상 시스템의 서비스를 마비시키는 공격형태다. 
* 일반적인 공격 구조를 살펴보면 다음과 같이 크게 4가지 구성요소로 이루어져 있다. 
  * 공격자(Attacker): C&C 서버에 공격 명령을 전달하는 해커의 컴퓨터를 말한다. 봇 마스터 라고도 한다. 
  * 명령제어(Command & Control) 서버: 공격자로부터 직접 공격 명령을 전달 받는 시스템을 말하며 전달받은 명령은 관리하는 다수의 좀비 PC/디바이스(악성 봇)에 전달한다. 마스터 또는 C2서버라고 한다. 
  * 좀비PC/디바이스: C&C서버로부터 전달받은 명령을 실행하여 공격대상에 실제 공격을 수행하는 PC/디바이스를 말한다. 봇, 슬레이브, 에이전트 라고도 한다. 
  * 공격대상: 공격의 대상이 되는 시스템을 말한다. 
* 일반적인 공격 절차는 다음과 같다. 
  * 공격자는 각 봇을 관리하고 명령을 내리는 C&C서버를 구축한다. 
  * 스팸 메일이나 악의적인 웹사이트 등을 통해 불특정 다수의 PC에 봇을 배포해 감염을 시도한다. 
  * 사용자가 봇 프로그램을 다운로드해 실행하면 봇에 감염된다. 
  * 봇이 C&C 서버에 접속함으로써 감염 PC는 봇넷의 일원으로 추가된다. 
  * 공격자가 C&C 서버에 명령을 내리면 C&C 서버는 봇에 명령을 전달한다. 
  * 봇은 명령에 따라 다양한 공격을 수행하며 스스로 다른 PC로 봇의 전파를 시도한다. 

# 봇/봇넷
* 봇은 소프트웨어적 로봇의 줄임말로 보안상 결함을 이용해 원격에서 해당 시스템을 제어할 수 있는 프로그램을 말한다. 이러한 악성 봇에 감염된 PC/디바이스를 좀비PC/디바이스 라고 한다. 
  * 일반적으로 봇은 웜/바이러스, 백도어, 스파이웨어, 루트킷 등 다양한 악성코드들의 특성을 복합적으로 가지고 있다. 
  * 봇은 공격자(봇 마스터)의 명령에 따라 활동하며 공격자가 감염된 PC/디바이스를 제어하여 정보 유출, 스팸 메일 발송, 디도스(DDoS) 공격, 트래픽 스니핑, 키 로깅 등 다향한 형태의 공격을 수행한다. 
* 봇넷이란 악성 소프트웨어인 봇에 감염된 다수의 좀비PC로 구성된 네트워크를 말한다. 좀비들은 C&C서버와 직접 통신하거나 좀비들 간에 서로 통신을 수행하면서 공격자의 명령을 수행한다. 
  * 합법적인 분산 네트워크로 봇넷 기술을 이용할 수 있지만 일반적으로 봇넷이라 하면 악의적인 의도를 가진 불법 네트워크를 의미한다. 
* 봇넷은 명령/제어를 위해 사요하는 프로토콜에 따라 IRC 봇넷, HTTP봇넷, P2P 봇넷으로 나뉜다. 네트워크 구성 방식에 따라 중앙 집중형 방식(IRC 봇넷, HTTP 봇넷)과 분산형 방식(P2P 봇넷)으로 분류할 수 있다. 
###### IRC
인터넷 상에서 채팅을 할 수 있도록 고안된 프로토콜로 IRC 서버 간에 직간접적으로 연결되어 있어 세계 어느 곳이든 한 서버에 연결하면 자동으로 전 세계의 모든 서버와 연결되는 구조이다. 봇 마스터는 IRC서버를 C&C서버로 활용하여 봇에 감염된 PC를 제어하는 형태로 동작한다. 




### 봇넷 명령 제어 방식
##### 중앙 집중형 명령/제어 방식
* 초기에는 구조가 유연하고 널리 사용되는 IRC의 특성을 이용한 IRC 봇넷이 주를 이루었으나 탐지 및 대응을 보다 어렵게 하기 위해 인터넷 상에서 많이 사용되는 웹 프로토콜인 HTTP를 기반으로 진화하였다. 
* 다수의 도메인을 확보하여 중앙 집중형 명령/제어를 하기 위한 C&C서버로 등록하고 다수의 좀비가 C&C서버와 연결되어 명령을 수행하는 구조이다. 
* 명령/제어 구조가 비교적 간단하지만 C&C서버가 탐지 및 차단되면 전체 봇넷이 중단될 가능성이 있다. 
* 대표적인 봇넷 유형에는 IRC봇넷(Rbot), HTTP 봇넷(Robac) 등이 있다. 
##### 분산형 명령/제어 방식
* 참여 멤버(좀비PC/봇)들이 모두 C&C역할을 하여 그룹에 명령을 전파하는 분산 제어 방식으로 중앙관리를 위한 별도의 도메인 및 C&C서버가 불필요하다. 
* 주로 봇넷을 보호하고 네트워크가 끊어지는 것을 방지하기 위한 방식으로 참여 멤버 모두 C&C 역할을 하므로 탐지 및 차단이 어렵다. 
* 대표적인 봇넷 유형에는 P2P봇넷(Storm, Peacomm)이 있다. 


### DNS 싱크홀 서비스
<!-- DNS 싱크홀 서비스 이미지 -->
* 악성 봇에 감염된 PC가 해커의 명령을 받기 위해 C&C서버로 연결을 시도할 때 C&C서버 대신 싱크홀 서버로 우회시켜 더 이상 해커로부터 조종 명령을 받지 않도록 해주는 시스템/서비스를 말한다. 
* 악성 봇을 미라 파놓은 구덩이(싱크홀 서버)로 유도하는 방식으로 이해할 수 있다. 
* 한국 인터넷 진흥원(KISA)에서 국내 주요 ISP 업체 및 가입기관과의 협력을 통해 DNS 싱크홀을 운영하고 있다. 
##### DNS 싱크홀의 동작과정
1. 사전 단계로 KISA에서 배포한 알려진 C&C 서버 목록을 ISP 등 DNS 싱크홀 적용기관의 DNS 서버에 주기적으로 업데이트한다. 
2. 악성 봇에 감염된 PC가 싱크홀이 적용된 DNS에 C&C서버에 대한 질의를 요청한다. 
3. DNS는 악성 봇(좀비PC)에 싱크홀 서버를 반환한다. 
4. 이를 통해 악성 봇은 C&C 서버가 아닌 싱크홀 서버로 접속하여 공격자의 명령으로부터 피해를 방지할 수 있다. 

### 봇넷의 보안 장비 우회 기법
* 일반적으로 봇넷을 구성하는 PC나 랜섬웨어 등의 악성코드(멀웨어)는 C&C 서버에 접속하는 과정에서 C&C서버 도메인에 대한 질의를 수행한다. 
  * 보안 장비 관점에서는 C&C 서버 도메인이나 IP 주소등이 알려지면 이를 블랙리스트로 등록하여 탐지 및 차단을 수행한다. 
  * 공격자의 관점에서는 확보한 봇넷 멤버들의 지속적 유지를 위해 보안장비를 통해 탐지되지 않도록 하는 것이 중요하다. 
* 따라서 공격자들은 봇넷 참여 멤버들의 C&C서버 접속 과정에서 보안장비에 의해 탐지되지 않도록 하기 위한 다양한 보안 장비 우회 기법을 적용하고 있다. 대표적인 기법은 다음과 같다. 
  * Fast Flux
  * DGA
  * Domain Shadowing

##### Fast Flux 기법
<!-- ##### Fast Flux 기법 이미지 -->
* 하나의 C&C 서버 도메인에 다수의 IP 주소를 할당하여 DNS 질의 시미다 지속적으로 IP 주소가 변경되도록 하는 기법이다. 
  * Flux의 사전적 의미는 지속적인 변화이다. 즉, 도메인 질의 시마다 C&C서버 IP 응답을 빠르게(Fast) 지속적으로(Flux) 변화시킨다는 의미이다. 
  * 미리 확보해 둔 다수의 C&C서버 IP 주소들을 DNS 레코드(A레코드)에 추가되도록 하고 TTL 값을 매우 작게 주어 빠르게 라운드 로빈으로 응답이 되도록 한다. 
* 만약 보안장비에 의해 Fast Flux IP 중에 어느 하나가 차단된다고 해도 다른 IP를 통해 지속적으로 C&C 서버에 접속할 수 있다. 
  * DNS질의 자체를 탐지할 수 있는 7계층 보안 장비가 없는 상황이라면 Fast Flux IP 일부만 차단해서는 C&C 서버로의 접속을 완전히 차단할 수 없다. 

##### DGA(Domain Generation Algorithm) 기법
<!-- ##### DGA(Domain Generation Algorithm) 기법 이미지-->
* 약속된 규칙에 따라 C&C 서버 도메인을 지속적으로 동적으로 생성하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다. 
  * 다수의 임시 C&C 서버 도메인이 동적으로 생성되기 때문에 보안장비의 입장에서는 이를 모두 탐지하고 차단하기 매우 어렵다. 
  * 컨피커 웜(Conficket Worm)에 의해 DGA 기법이 처음 알려졌으며 Locky(시스템 날짜 기반으로 도메인명 생성), WannyCry 랜섬웨어 등에 사용된다. 
* 알고리즘에 따라 도메인을 다수 생성하기 때문에 공격자는 해당 알고리즘에 따라 생성될 수 있는 도메인 중 하나를 DNS 서버에 새롭게 등록하는 방식을 사용한다. 만약 등록한 도메인이 블랙리스트로 차단되면 다른 도메인명을 재등록한다. 

##### Domain Shadowing 기법
<!-- ##### Domain Shadowing 기법 이미지 -->
* 알려진 합법적인 도메인의 서브도메인을 C&C 서버 도메인으로 사용하여 도메인 기반의 탐지 및 차단을 우회할 수 있는 기법을 말한다. 
    * 적합한 절차로 도메인을 소유하고 있는 도메인 관리자의 개인정보 등을 탈취하여 도메인 소유자 몰래 많은 서브도메인을 등록시켜놓고 사용하는 기법
    * 드라이버 바이 다운로드 공격 도구인 앵글러 익스플로잇 도구에서 탐지 회피를 위한 기술로 사용되어 알려졌다. 
* 주로 드라이브 바이 다운로드 공격에서 악성코드 유포지로 흘러가는 길목에 사용되는 경유지 도메인을 서브도메인으로 사용한다. 

# DDoS 공격 유형

||대역폭 소진 공격|서비스(어플리케이션) 마비 공격|
|:--:|:--|:--|
|대표<br>공격유형|UDP/ICMP Flooding, SYN Flooding| HTTP GET Flooding|
|공격<br>형태|1. UDP/ICMP Traffic Flooding<br> * UDP/ICMP Traffic Flooding, DNS Query Flooding 등 <br>2. TCP Traffic Flooding<br> * SYN Flooding, SYN+ACK Flooding <br>3. IP Flooding<br> * Land Attack, TearDrop, HTTP Continuation 등|1. HTTP Traffic Flooding<br> * GET Flooding, CC Attack 등 <br>2. HTTP Header/Option Spoofing <br> * Slowloris, Pyloris 등 <br>3. TCP Traffic Flooding <br> * TCP Session, SYN Flooding, TCP Slow Read 등 <br> 4. Other L7 Service Flooding <br> * Hash Dos, Hulk DoS, FTP/SMTP Attack 등|
|프로토콜|3~4계층 <br>: IP, ICMP, TCP, UDP 등| 7계층<br>:HTTP, DNS, FTP, SMTP|
|증상|* 회선 대역 고갈<br> * 동일 네트워크를 사용하는 모든 서비스에 대한 접속장애 발생|* HTTP 서버 과다 접속(또는 서비스 부하)으로 인한 장애 발생<br> * 공격 대상 시스템만 피해|
|공격대상|네트워크 인프라|웹서버, 정보보호 장비 등|

### 네트워크 대역폭 소진 공격
1. UDP Flooding
   * 공격자가 다량의 UDP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 가득 채워 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격 
   * DNS 서비스(53/udp)로 다량의 UDP 패킷을 전송한다. 
   * 짧은 시간동안에 다량의 UDP 패킷이 출발지 IP가 다양한 주소로 위조되어 전송된다면 다수의 좀비PC에 의해 UDP 공격이 발생한 것으로 판단할 수 있다. 
   * `tcpdump -nn "udp"` tcpdump의 BPF 옵션을 udp 로 설정하여 해당 트래픽만 캡쳐할 수 있다. 

2. ICMP Flooding
    * 공격자가 다량의 ICMP 패킷을 서버로 전송하여 서버가 보유한 네트워크 대역폭을 가득 채워 다른 정상적인 클라이언트의 접속을 원활하지 못하도록 유발시키는 공격
    * 매우 짧은 시간동안 출발지IP 위조된 다량의 ICMP 패킷(ICMP Echo Request)이 Target Server로 전송된다면 ICMP Flooding이라고 판단할 수 있다. 
    * `tcpdump -nn "icmp"` tcpdump의 BPF 옵션을 icmp 로 설정하여 해당 트래픽만 캡쳐할 수 있다. 

3. DNS Query Flooding 
    * 공격자는 UDP 프로토콜 기반의 서비스를 제공하는 DNS에 대해 DNS 쿼리 데이터를 다량으로 서버에 전송하여 DNS의 정상적인 서비스를 방해하는 공격

### 서버/서비스 자원 소진 공격
4. TCP SYN FLooding
   * 공격자의 다량의 SYN 패킷을 서버로 전달하여 서버의 대기큐를 가득 채워 새로운 클라이언트의 연결 요청을 무시하도록하여 장애를 유발시키는 공격
   * 공격원리
        <!-- 공격원리 이미지 -->
        * Client가 Server로 요청을 보내면 Server는 SYN+ACK 응답을 보내고 해당 연결 정보를 incomplete connection queue에 저장한다. 
        * Client로부터 ACK를 받아 연결이 완료되면 incomplete connection queue에 있던 연결 요청 정보를 completed connection queue로 이동, accept() 시스템 콜을 통해 클라이언트와 통신할 연결 소켓이 생성되면 연결 요청정보는 삭제된다. 
        * TCP SYN Flooding 공격은 다수의 TCP 연결을 완료하지 않아 incomplete connection queue를 꽉 차게 만들어 더 이상 새로운 연결 요청을 받을 수 없도록 하는 공격이다. backlog queue의 크기는 incomplete와 complete queue 크기의 합이다. 
        * 공격자는 imcomplete connection queue를 소진시키기 위해 출발지 IP를 도달 불가능한(존재하지 않는) IP로 위조한 SYN 요청을 보내 서버 측의 SYN+ACK 요청에 대한 ACK 응답이 발생하지 않도록 만든다. 
   * 공격대상 측 소켓 상태
        * `netstat -antp |grep SYN RECV` 로 확인
        * Client가 Server로 SYN packet을 보내면 Server는 SYN+ACK를 보내고 해당 연결설정이 완료될 때까지 Backlog queue(연결 요청 대기 큐)에 담아둔다. 
        * 정상적인 연결이라면 클라이언트로부터 SYN+ACK에 대한 ACK 응답을 받아 연결설정이 완료되지만, SYN Flooding 공격의 경우 ACK 응답이 오지 않아 Backlog queue에 연결 정보가 계속 쌓이게 된다. netstat -an 명령어를 통해 소켓 상태를 살펴보면 다수의 SYN_RECV 상태의 tcp 소켓을 확인할 수 있다. SYN_RECV 상태는 ACK 응답을 대기하고 있는 상태이다. 
        * Backlog queue가 꽉 차게 되면 더 이상 연결 요청을 받을 수 없어 정상적인 서비스 제공이 불가능하다. 
    * 패킷 캡쳐
        *  `tcpdump -nn "tcp port 80"` 또는 Wireshark에서 Time 항목을 살펴 매우 짧은 시간동안 TCP 연결요청(SYN)이 Target서버로 발생했다면 TCP SYN Flooding으로 판단할 수 있다. 
        * 위조된 출발지 IP 중에는 실제로 존재하는 IP도 있으며, 이 경우 상대방으로투버 RST응답이 발생하는 것을 확인할 수 있다. 
    * 대응책
        * 완전한 3-Way Handshaking이 이루어지지 않는다면 Backlog Queue가 소비되지 않도록 설정한다. 대표적으로 Syn Cookie 설정을 이요할 수 있다. <br> `sysctl -w net.ipv4.tcp_syncookies=1`
        * 방화벽 또는 DDoS 대응 장비를 이용하여 동일 Client(IP)의 연결(SYN) 요청에 대한 임계치(Threshold) 설정을 통해 과도한 연결 요청이 발생하는 것을 차단한다. itables를 이요한 설정 예를 들어 살펴보면 <br> `itables -A INPUT -p TCP --dport 80 --syn -m connlimit --conlimit-above 5 -j DROP`: TCP 80포트 연결 요청(syn)에 대하여 동일 출발지 IP 로 동시 연결 개수가 5개 초과시 이를 차단
        * First SYN Drop 설정을 한다. 연결 요청 패킷을 보내는 클라이언트가 실제로 존재하는지를 파악하는 방법으로 클라이언트로부터 전송된 첫번째 SYN은 DROP 하여 재요청 패킷이 도착하는 지 확인하여  출발자 IP가 위조(Spoofing) 되었는지 판단한다. 대부분의 공격 툴이 다량의 SYN 요청을 생성할 뿐 패킷 Drop시 재전송을 수행하지 않는 점을 이용한 방법이다. 
        * Backlog Queue의 크기를 늘려준다. 이 방법은 임시적인 조치는 되지만 대규모 공격이 발생했을 때는 순식간에 queue가 full 상태가 되기 때문에 효과를 보기 어렵다. 
        * SYN+ACK 에 대한 대기시간을 줄인다. 대기시간을 너무 줄이면 정상 요청에 문제가 생길 수 있다. 

5. HTTP GET Flooding
    <!-- HTTP GET Flooding 이미지 -->
    * 공격자는 동일한 동적컨텐츠에 대한 HTTP GET 요청을 반복 요청하여 웹서버가 URL에 해당하는 데이터를 처리하기 위해 서버자원을 사용하도록 하여 정상적인 요청을 처리하지 못하도록 하는 서비스 거부 공격
    * 동일한 URL로 다량의 GET 요청을 발생시킨다. 
    * `ngrep -qtw byline |grep GET` 을 통해 얼마나 많은 GET 요청이 발생했는지 알 수 있다. 


8. HTTP Countinuation
    * 서버로 전달되는 패킷에 HTTP 헤더 없이 Data만 채워 웹서버가 지속적으로 데이터 수신을 위해 TCP 자원을 사용하도록 하는 공격

9.  HTTP GET Flooding with Cache-Control(CC Attack)
    *  공격자는 HTTP 메시지의 캐시 옵션(Cache-Control: no-store, must-revalidated)을 조작하여 캐싱 서버가 아닌 웹서버가 직접 처리하도록 유도하여 캐싱서버의 기능을 무력화하고 웹 서버의 자원을 소모시키는 공격


14. 헐크도스(HulkDos) 공격
    *  Get Flooding 공격 유형으로 동일 URL을 지속적으로 요청 시 차단될 수 있기 때문에 이를 우회하기 위해 URL을 지속적으로 변경하여 공격하는 방식
    *  주소(URL)을 지속적으로 변경하는 이유는 임계치 기반의 디도스 대응 장비를 우회하기 위함이다. 특정 자원(URL)에 접근하는 횟수를 제한하는 임계치 기반 디도스 대응 장비의 경우 주소가 계속 변경되면 서로 다른 주소로 인식하여 정상적인 차단이 불가능해진다. 
    *  HTTP 요청 URL 의 파라미터를 계속 변경시키면서 다수의 요청이 전송된다면 HulkDos 공격으로 판단할 수 있다. 

13. 해시도스(HashDoS) 공격
    * 웹서버는 클라이언트로부터 전달받은 HTTP 메시지의 매개정보(Parameter)관리를 위해 해시 테이블을 사용한다. 조작된 매개정보를 포함한 다량의 메시지는 해시 테이블 검색을 위한 인텍스로 사용되는 해시값에 충돌을 발생시켜 정확한 값을 찾기 위해 모든 해시테이블을 검사하게 되는데 이때 웹서버의 CPU 자원을 소진하게 되어 정상적인 서비를 방해한다. 
    * 매우 긴 데이터 전달이나 조작된(수상한?) 파라미터 정보가 전달되는 경우 해시도스 공격으로 판단할 수 있다. 

6. TCP Flag Flooding 
    * TCP의 Flag값을 임의로 조작하면 SYN, ACK, FIN, RST와 같이 여러 형태의 패킷을 생성할 수 있으며, 서버는 이러한 패킷을 수신하는 경우 해당 패킷을 검증하기 때문에 서버 자원을 소모시키는 공격


7. TCP Session Flooding
    * TCP 3-Way Handshake 과정을 과도하게 유발하여 서비스의 과부하를 유발하는 공격 

### Slow 계열 공격 유형

11. Slow HTTP Header DoS(Slowloris)
    *  웹서버는 HTTP 메시지의 헤더부분을 먼저 수신하여 이후 수신할 데이터의 종류를 판단하게 되는데, 헤더 부분을 비정상적으로 조작하여 웹서버가 헤더 정보를 구분할 수 없도록 하면 웹 서버는 아직 HTTP 헤더 정보가 모두 전달되지 않은 것으로 판단하여 연결을 장시간 유지하게 된다. 
    * HTTP 요청 메시지는 요청라인, 요청헤더, 빈 라인, 메시지 바디로 구성되어 있다. 개행은 CRLF (Carriage Return: 행의 맨 앞으로 이동, Line Feed: 다음 행으로 이동)를 의미하는 것으로 16진수 값으로 0x0d0a 로 표현하고 있다. 
    * 요청 헤더를 보면 여러 헤더 필더들로 구성되어 있고 각 헤더 필드는 개행을 통해 구분된다. 마지막 헤더 필드에 대한 개행처리가 되고 나면 요청 헤더의 끝(요청 헤더와 메시지 바디부를 구분)을 식별하기 위한 빈 라인이 추가된다. 
    * 기본적으로 웹서버는 클라이언트의 HTTP 요청 메시지가 들어오면 먼저 요청 헤더부까지 모두 수신한 후 헤더 필드들을 분석하여 이후 메시지 바디부를 어떻게 처리할지 결정하게 되는데, 공격자는 이 부분의 취약점을 이용하여 공격을 수행할 수 있다. 
    * 공격자가 만약 요청 헤더의 끝, 즉 빈라인을 전달하지 않고 지속적으로 천천히 불필요한 헤더 정보를 전달한다면 웹서버는 요청 헤더부를 모두 수신해야 요청 메시지 처리가 가능하기 때문에 이를 모두 수신할 떄까지 연결 상태를 유지하면서 대기하게 된다. 이러한 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원(가용량: 웹서버로 접속할 수 있는 최대 클라이언트 수)이 모두 소진되어 정상적인 요청을 받을 수 없는 상태가 된다. 
    * 이와 같은 방식으로 HTTP요청 헤더 정보를 조작해서 시비스 거부 공격을 수행하는 것을 Slow HTTP Header Dos, 일명 Slowloris 공격이라 한다. Slow 계열의 공격 특징 중 하나는 기존의 다량의 트래픽을 발생시키는 DDoS 공격 기법과는 달리 웹 서버의 연결 상태를 지속시키는 방식이기 때문에 연결자원을 소진시킬 정도의 트래픽만을 필요로 하므로 저대역폭 공격이라는 특징이 있다. 
    * 의미없는 헤더 필드 + 개행(0x0d0a) + 빈 라인(Empty Line)없음 → Slow HTTP Header DoS
    * 0d 0a 0d 0a 가 없을 때  → 0d 0a 만 있을 때


12. Slow HTTP POST DoS(RUDY)
    *  HTTP POST 메소드를 이용하여 서버로 전달할 대량의 데이터를 장시간에 걸쳐 분할 전송하면 서버는 POST 데이터가 모두 수신하지 않았다고 판단하여 연결을 장시간 유지하게 하는 공격
    *  브라우저는 HTTP 요청을 통해 데이터를 웹서버로 전달하고자 할 때 POST 메소드를 사용하는데, 메시지의 유형과 크기 정보를 전달하기 위해 Content-Type 헤더 필드와 Content-Length 헤더 필드를 사용한다. 
    *  기본적으로 웹서버는 Content-Length 헤더 필드를 참고해서 데이터의 유형을 파악하고, Content-Length 헤더 필드를 참고해서 데이터의 길이를 파악한 후 해당 데이터의 길이만큼 읽어 들이는 작업을 수행한다. 공격자는 이 부분의 취약점을 이용하여 공격을 수행할 수 있다. 
    *  공격자는 Content-Length를 비정상적으로 크게 설정한 후 매우 소량의 데이터를 지속적으로 천천히 웹 서버에 전송하면 웹서버는 Content-Length 헤더 필드에 명시된 크기만큼 데이터를 모두 수신하기 위해 연결 상태를 유지하면서 대기하게 된다. 이런 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원이 모두 소진되어 정상적인 요청을 받을 수 없는 상태가 된다. 
    *  이처럼 POST 메소드로 데이터를 전송하면서 Content-Length 헤더 필드와 전송 데이터를 조작해 서비스 거부 공격을 수행하는 것을 Slow HTTP POST Dos, 일명 RUDY 공격이라 한다. 
    * 큰 크기의 Content-Length를 설정하고 실제 전송데이터는 조금만 보내면 웹서버 입장에서는 수신할 데이터가 많이 남아있다고 판단하여 연결을 지속시키면서 다음 요청을 대기하게된다. 

12. Slow HTTP Read DoS
<!-- Slow HTTP Read DoS 이미지 -->

  * 공격자는 웹서버와 TCP 연결 시, TCP 윈도우 크기 및 데이터 처리율을 감소시킨 후 HTTP 데이터를 송신하여 웹서버가 정상적으로 응답하지 못하도록 DoS 상태를 유발한다. 
  * TCP 흐름 제어란 연결된 상호 간에 수신 가능한 양만큼만 데이터를 전송하는 제어방식을 의미한다. 즉, 수신 측의 수신버퍼에 충분한 여유 공간이 없다고 송신 측에 알려주면 송신측은 수신 측에서 여유 공간이 생겼다고 알려줄 때까지 대기함으로써 흐름 제어를 하게 된다. 
  * TCP 헤더의 Window 필드가 수신 측에서 수신 가능한 여유 공간의 크기를 담아서 송신 측에 전달하는 헤더 필드이다. 만약 수신 측의 수신 버퍼에 여유 공간이 0이되면 Window 필드를 0으로 설정한 "Zero Window Packet"을 전달하고, 이를 수신한 송신 측에서 일정 시간 대기 후 수신측 상태를 확인하기 위한 "Zero Window Probe Packet"을 전달한다. 이를 수신한 수신 측에서 여유 공간이 생겼다면 해당 공간의 크기만큼 Window 필드를 설정하여 응답하고 (Window Update Packet) 여전히 여유 공간이 없다면 "Zero Window Packet"으로 응답한다. 
  * 공격자는 이러한 TCP 흐름 제어 특성을 이용해서 HTTP 요청을 보낸 후 Window 크기를 조작하여 0인 "Zero Window Packet"을 지속적으로 서버 측에 전달하여 서버가 요청에 대한 응답메시지를 전송하지 못하고 연결을 지속적으로 유지하도록 한다. 이런 방식으로 다수의 연결을 지속시키게 되면 대상 웹서버의 연결 자원이 모두 소진되어 정상적인 요청을 받을 수 없게 된다. 
  * 공격자가 TCP 흐름제어를 이용해서 요청에 대한 응답으로 느리게(Slow) read하여 서비스 거부공격을 수행하는 것을 Slow HTTP read DoS 공격이라 한다. 
  * `Window Size value : 0` →   Slow HTTP read DoS 

### Slow HTTP Header/POST 공격 대응책
* 동시 연결에 대한 임계치 설정을 통한 차단
  * 동일한 출발지 IP 에서 동시에 연결할 수 있는 연결 개수에 대한 임계치를 설정한다. 
  * iptables 방화벽을 이용한다면 다음과 같은 룰 설정이 가능하다. 
  * `iptables -A INPUT -p tcp --dport 80 -m connlimit --conectlimit-above 30 -j DROP` : 30개 초과 동시 연결에 대해 차단(DROP)
* 연결 타임 아웃(Connection Timeout) 설정을 통한 차단
    * 클라이언트와 웹 서버 간에 아무런 데이터 송수신 없이 세션을 유지하는 시간에 대한 타임아웃 설정을 하여 연결을 종료한다. 
    * Apache 웹서버의 경우 httpd.conf의 Timeout 지시자를 120에서 작은 값(5)으로 변경하는 것을 추천한다. 설정 값은 환경에 따라 적절한 값을 설정한다. 
    * 공격자가 방어 정책을 우회하기 위해 데이터 전송 주기를 짧게 가져갈 수 있으므로 이 방안에는 일정한 한계가 있다. 또 너무 작은 Timeout을 설정하면 정상적인 서비스에 영향을 줄 수도 있다. 
  * 읽기 타임아웃(Read Timeout)  설정을 통한 차단
    * Apache 2.2.15 버전 이상에서 클라이언트의 요청에 대한 더욱 세부적인 제한을 줄 수 있다. 요청 헤더와 바디 각각에 대하여 타임아웃을 지정하여 지정한 시간 내에 read를 완료하지 못하면 클라이언트에게 오류코드를 반환한다. 
    * 요청 헤더 정보가 5초 이내에 모두 수신되지 않거나(Slow HTTP Header 공격 대응) 요청 바디 정보가 10초 이내에 모두 수신되지 않으면 (Slow HTTP POST 공격 대응) 오류 응답 한다. 



















