# TCP 프로토콜
### 연결지향 프로토콜
* 물리적으로 전용회선이 연결되어 있는 것처럼 가상의 연결통로를 설정해서 통신하는 방식으로 가상의 연결통로를 가상회선이라 한다. 가상회선 방식이란 물리적으로 전용회선이 연결되어 있는 것처럼 논리적으로 동작하는 방식을 말한다. 
* 논리적인 연결통로를 통해 데이터를 주고 받음으로써 데이터이 전송순서를 보방해준다. 이를 `순서제어`라고 한다. 
* 스트림 기반의 전송방식을 사용한다. 즉 데이터를 정해진 크기로 전송하는 것이 아니라 임의의 크기로 나누어 연속해서 전송하는 방식을 사용한다. 


### 신뢰할 수 있는 프로토콜
##### 흐름제어
* 흐름제어란 상대방이 받을 수 있을 만큼만 데이터를 효율적으로 전송하는 것을 말한다. 
* 흐름제어를 위해 슬라이딩 윈도우 제어방식을 사용한다. 이는 상대방이 수신 가능한 크기 내에서 데이터를 연속해서 전송하는 방식으로 세그먼트 전송 시마다 수신확인응답(ACK)을 수신한 후 전송하게 되면 왕복시간(RTT)이 길 경우 단위 시간당 데이터 전송량이 매우 떨어지므로 효율적으로 전송하기 위해 상대방이 받을 수 있는 범위 내에서 연속적으로 전송한다. 
##### 오류제어
* 오류제어란 데이터의 오류나 누락없이 안전한 전송을 보장해주는 것을 말한다. 
* 오류 또는 누락 발생 시 재전송을 수행하여 이를 보정한다. 
##### 혼잡제어
* 혼잡제어란 네트워크의 혼잡 정도에 따라 송신자가 데이터 전송량을 제어하는 것을 말한다. 
* 혼잡 정도에 대한 판단기준은 데이터의 손실 발생 유무로 판단한다. 전송한 데이터에 누락이 발생하면 네트워크가 혼잡한 상태로 판단하여 전송량을 조절한다. 




# TCP 프로토콜 구조
<!-- TCP 프로토콜 구조 이미지 -->
1. Source Port(16): 출발지(송신) 포트 번호
2. Destination Port(16): 목적지(수신) 포트 번호
3. Sequence Number(32): 송신 데이터 순서번호, 송신시 전송하는 데이터의 시작 바이트 순번을 담는다. 바이트 순번은 전송하는 데이터의 바이트 단위로 부여하는 연속된 번호를 의미한다. 연결설정 단계에서 초기 순서 번호(ISN:Initial Sequence Number)를 상호 간에 주고 받는다. 초기 순서번호는 0부터 시작하는 것이 아니라 임의의 수를 할당해서 사용한다. 
4. Acknowledgment Number(32): 상대방이 다음에 전송할 순서번호, 수신 확인 응답(ACK)과 함께 해당 필드에 상대방이 다음에 전송할 순서번호를 담아서 보낸다. 
5. HLEN(4): 헤더길이
6. Reserved(6): 예약(사용하지 않음)
7. Control Flags(6):
    * URG(Urgent pointer is valid): 긴급 데이터(OOB: Out Of Band) 설정
    * ACK(Acknowledgment is valid): 수신 확인 응답 (ACK) 설정
    * PSH(Request for push): 송수신 버퍼에 있는 데이터를 즉시 처리
    * RST(Reset the connection): 연결 중단(강제 종료)
    * SYN(Synchronize sequence numbers): 연결 설정
    * FIN(Terminate the connection): 연결 종료(정상 종료)
8. Window Size(16):
    * 수신 측에서 송신 측에 보내는 Receiver window size 수신버퍼의 여유 공간 크기를 의미한다. 송신 측에서는 상대방의 여유 공간 크기를 통해서 흐름제어를 수행할 수 있다. 
    * 따라서 송신 측에서는 상대방의 윈도우 크기 범위 내에서 수신 측의 수신 확인 응답(ACK)을 기다리지 않고 연속적으로 전송할 수 있는데 이를 슬라이딩 윈도우 제어 방식이라고 한다. 
9. Checksum(16): 헤더를 포함한 전체 세그먼트에 대한 오류를 검사하기 위한 필드
10. Urgent Pointer(16): 세그먼트가 긴급 데이터를 포함하고 있는 경우에 사용되는 필드로 긴급 데이터의 위치값을 담고 있다. 

# TCP 분할(Segmentation) 과 재조합(Reassembly)
<!-- TCP 분할 재조합 이미지 -->
### MSS(Maximum Segment Size)
* TCP 세그먼트 데이터부의 최대 바이트 수를 의미하며 연결 설정 과정에서 상호 간에 MSS 정보를 주고 받는다. (TCP 옵션 헤더의 MSS 필드)
* MSS는 Frame의 MTU에 영향을 받는다. MTU 크기에서 IP 헤더(20)와 TCP 헤더(20)를 빼면 MSS 크기를 알 수 있다. 
* 송신측 Application 계층에서 전달된 데이터는 TCP 계층에서 MSS 크기에 따라 분할이 발생한다. 분할된 세그먼트는 수신 측에서 재조합되어 Application 계층으로 전달된다. 


# 연결 설정 과정(3-Way Handshake)
 <!-- 연결 설정 과정(3-Way Handshake) 이미지 -->
1. 
* 최초 클라이언트는 서버와 연결 설정을 위한 연결 요청 패킷(SYN 패킷)을 보낸다. 연결 요청을 위해 능동적으로 포트를 열고 있는 사태를 "Active Open", 연결 요청을 수용하기 위해 수동적으로 포트를 열고 있는 상태를 "Passive Open" 이라 한다. 
* SYN은 동기화의 줄임말로 상호 간에 순서번호를 동기화하자는 의미이다. 상호 간의 초기 순서번호는 0부터가 아닌 임의의 값으로 시작한다. 
* 최초 SYN 패킷을 보낸 TCP(소켓) 상태를 SYN_SENT 상태라 한다. 


#### 두 번째 단계
* 클라이언트 연결 요청(SYN 패킷)에 대한 수신 확인 응답(ACK)과 함께 서버에서 클라이언트로 연결 요청(SYN 패킷)을 보내 상호 간에 연결 요청을 수행한다. 
* 수신 확인 응답(ACK)을 하게 되면 Acknowledgment Number를 설정하는데 그 의미는 상대방이 다음에 보낼 패킷의 순서번호를 의미한다. 예를 들면 ACK Num:1001 로 설정되어 있다면 그 의미는 1000번까지 수신 완료했고(첫번째 SYN 패킷) 1001을 보내라는 의미이다. 
* 상대방의 SYN 패킷을 수신한 TCP 소켓 상태를 "SYN_RECEIVED" 상태라고 한다. OS에 따라서는 "SYN_RECV", "SYN_RCVD" 등으로 줄여서 표현한다. 
  
#### 세 번째 단계
* Server의 연결요청(SYN 패킷)에 대해 수신 확인 응답을 전송한 후 최종적으로 연결 설정이 완료된다. 
* 연결 설정이 완료되면 TCP(소켓) 상태는 ESTABLISHED 상태가 된다. 

# 데이터 송수신 과정

### 재전송 과정
<!-- 데이터 재전송 과정 이미지 -->

1. TCP는 모든 세그먼트 전송 시마다 재전송 타이머가 동작한다. 재전송 타임아웃(RTO)동안 상태방으로부터 ACK 응답이 없으면 송신자는 해당 패킷이 누락된 것으로 판단하여 재전송을 수행한다. 
2. 재전송은 일정시간/횟수 동안 발생하며 더이상 상대방으로부터 ACK응답이 없으면 연결을 종료한다. 
3. 혼잡제어 관점에서는 재전송 타이머 만료에 따른 재전송이 발생하는 상황을 매우 혼잡한 상태로 판단한다. 
### 빠른 재전송 과정
<!-- 데이터 빠른 재전송 과정 이미지 -->
1. TCP는 수신측이 기대했던 순서번호가 아닌  그 이후 순서번호의 세그먼트를 수신하면(일부 세그먼트의 손실/지연 발생이나 순서가 맞니 않는 상황 발생) 즉시 기대하는 순서번호의 세그먼트를 요청하는 ACK 패킷을 전송한다. 
2. 클라이언트는 중복 ACK 가 두번 발생할 때까지는 일시적으로 서버에 전달한 세그먼트의 순서가 맞지 않는 상태로 판단하다가 세 번 발생하면 해당 세그먼트가 누락된 것으로 판단하여 재전송을 수행한다. 재전송 타임아웃 발생 이전에 중복 ACK가 세번 발생하면 즉시 재전송을 수행하므로 이를 빠른 재전송이라 한다. 
3. 혼잡제어 관점에서는 중복 ACK 3회 발생에 따른 빠른 재전송이 발생하는 상황은 재전송 타이머 만료에 따른 재전송에 비해 덜 혼잡한 상태로 판단한다. 이는 일부 새그먼트의 누락은 발생했지만, 나머지 세그먼트는 정삭적으로 수신되었기 때문에 덜 혼잡한 상태로 본다. 


# 연결 종료 과정(4-Way Handshake)
 <!-- TCP 연결 종료 과정(4-Way Handshake) 이미지  -->
#### 첫 번째 단계
* 클라이언트는 서버와의 연결설정을 종료하기 위한 연결 종료 패킷(FIN + ACK)을 보낸다. 능동적인 연결 종료 수행을 "Active Close" 라 한다. 수동적으로 수행하는 것을 "Passive Close"라 한다. 

#### 두 번째 단계 / 세 번째 단계
* 클라이언트 연결 종료 요청에 대한 수신 확인 응답(ACK)를 보낸다. 
* 서버는 해당 서버 애플리케이션에서 TCP 연결 종료를 할 때까지 대기한 후 종료되면 클라이언트에 연결 종료 패킷(FIN + ACK) 패킷을 보낸다. 
#### 네 번째 단계
* 서버의 연결 종료 패킷을 수신한 클라이언트는 즉시 연결을 종료하는 것이 아니라 서버에 마지막 ACK를 보낸 후 2MSL(Maximum Segment Lifetime) 시간 동안 대기한다. 
* 2MSL 동안(통상 1~4분) 대기하는 이유는 마지막 ACK 응답이 안전하게 상대방에게 전송됨을 보장해주기 위한 것으로 만약 서버가 마지막 ACK를 수신하지 못했다면 FIN + ACK 재전송이 발생할 것이고 이를 처리하기 위해 일정 시간 대기한다. 

* 연결 종료 단계의 TCP 소켓 상태
|상태|설명|
|--|--|
|FIN_WAIT_1|첫 번째 FIN+ACK 패킷에 대한 ACK를 대기하는 상태|
|FIN_WAIT_2|첫 번째 FIN+ACK 패킷에 대한 ACK 수신 후 두 번째 FIN+ACK 패킷을 수신할 때까지 대기하는 상태|
|TIME_WAIT|마지막 ACK 전송 후 2MSL 동안 대기하는 상태|
|CLOSE_WAIT|상대방의 첫 번째 FIN+ACK 패킷에 대한 ACK 응답 후 두번째 FIN+ACK 패킷을 전송할 떄까지 대기하는 상태|
|LAST_ACK|두 번째 FIN+ACK 패킷 전송 후 마지막 ACK를 대기하는 상태|
|CLOSED|종료된 상태|

### 연결 요청 거부 (강제 종료)
<!-- 연결 요청 거부 (강제 종료) 이미지 -->
* 클라이언트 TCP가 연결을 위해 SYN 요청을 전송했으나 서버에 해당 포트(서비스)가 준비되어 있지 않으면(Listen하고 있지 않음) "RST+ACK" 패킷을 클라이언트에 전송하여 연결 요청을 거부하게 된다. 
* "RST+ACK"를 수신한 클라이언트 TCP는 즉시 종료(CLOSED) 상태가 된다. 

### 연결 중단(abort)
<!-- 연결 중단(abort) 이미지 -->
* 연결 상태에 있는 클라이언트가 연결을 즉시 중단해야할 필요가 있을 경우 "RST+ACK" 또는 "RST" 패킷을 서버에 전송할 수 있다. TCP 표준(RFC 793)에 따른 차이점은 다음과 같다. 
  * RST 플래그만 설정하는 경우: 상대방으로부터 수신한 세그먼트에 Acknowledgment Number 필드가 설정되어 있는 경우 RST 플래그와 Sequence Number 필드를 설정하여 응답한다. 
  * RST + ACK 플래그를 설정하는 경우: 상대방으로부터 수신한 세그먼트에 Acknowlegment Number 플래그가 설정되어 있지 않은 경우 Sequence Number 필드를 0으로 설정하고 Acknowledgment Number 필드를 수신한 세그먼트의 Sequence Number와 세그먼트 길이의 합으로 설정하여 응답한다. 
* "RST+ACK" 또는 "RST" 패킷을 수신한 서버 TCP는 즉시 종료(CLOSED) 상태가 된다. 

### TCP 세션 하이재킹(Session Hijacking)
* 세계적으로 유명한 해커 케빈 미트닉이 사용했던 공격방법의 하나로 TCP의 세션 관리 취약점을 이용한 공격이다. 
* TCP는 연결설정 과정을 통해 상호 간에 세션을 생성한 후 다음 식별자를 통해 상호 간에 인식하게 된다. 
  * 출발지 IP 와 Port, 목적지 IP와 Port 
  * Sequnce Number 와 Acknowledgment Number 
* TCP 세션 하이재킹은 위와 같은 세션 식별 정보를 공격자가 위조하여 세션을 탈취하는 공격이다. 즉 공격자는 정상적인 사용자의 출발지 IP와 Port로 위조하고 Sequnce Number를 예측하여 세션을 탈취하게 된다. 

* 동작방식
  1. 공격자는 클라이언트와 서버 사이에서 ARP 스푸핑을 통해 둘 사이의 TCP 식별정보를 탈취하기 위한 스니핑을 진행한다. 
  2. 패킷을 스니핑하던 공격자는 정상적인 클라이언트 IP 주소로 위장한 TCP 패킷에 정삭적인 클라이언트의 TCP 식별정도(Port, Sequence Number, Acknowledgment Number)를 담아서 서버로 전달한다. 
  3. 서버는 공격자의 위조된 패킷에 대해 정상 응답(ACK)를 준다. 해당 응답은 공격자 뿐만 아니라 정상 클라이언트에게도 전달되고 클라이언트 입장에서는 데이터를 보내지 않았는데 Acknowledgment number가 증가한 응답을 받게 되는 상황이 발생한다. 
  4. 잘못된 응답(Acknowledgment Number가 틀린)을 받은 정상 클라이언트는 이를 교정하기 위해 ACK를 보낸다. 
  5. 서버 입장에서는 정산 클라이언트가 보낸 잘못된 ACK(교정용) 패킷을 다시 교정하기 위해 ACK 패킷을 보내게 된다. 이러한 과정이 반복적으로 대량 발생하게 되는데 이를 `ACK STORM` 이라 한다.  공격자에 의해서 해당 세션의 Sequnce Number 와 Acknowledgment Number가 조작된 것이기 때문에 정산 클라이언트와 서버 간에는 아무리 교정을 위한 ACK를 보낸다고 해도 이를 해결할 수 없다. 
  6. 공격자는 최종적으로 정상 클라이언트에 RST(강제종료) 메시지를 전달하여 연결을 강제로 종료하고 자신은 서버와의 세션을 유지한다. 



