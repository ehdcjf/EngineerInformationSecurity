# 시스템 해킹

### 패스워드 크래킹

1. **사전 공격/사전 대입 공격(Dictionary Attack)** 패스워드로 자주 사용되는 사전에 있는 단어 + 키보드 자판의 일련 순서(e.g. asdf qwer1234 등) + 주민등록번호, 이름 등을 미리 사전 파일로 만든 후 이를 하나씩 대입하여 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법\

2. **무차별 공격/무작위 대입 공격(Brute Force Attack)** 패스워드에 사용될 수 있는 문자열의 범위를 정하고, 그 범위 내에서 생성 가능한 모든 패스워드를 생성하여 이를 하나씩 대입, 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법. 일반적으로 사전 대입 공격 실패 후 무차별 공격을 진행한다.\

3. **혼합공격(Hybrid Attack)** 사전 공격과 무자별 공격을 혼합한 방식으로 사전 파일에 있는 문자열에 문자, 숫자 등을 추가로 무작위 대입하여 패스워드 일치 여부를 확인하는 패스워드 크래킹 방법. 일반적으로 사전 파일에 나오는 문자열 뒤에 숫자나 문자를 추가하는 형태의 패스워드가 많이 사용되는 점을 악용\

4. **레인보우 테이블을 이용한 공격** 레인보우 테이블은 하나의 패스워드에서 시작해 특정한 변이 함수를 이요해 여러가지 변이된 형태의 패스워드를 생성한다. 그리고 각 변이된 패스워드의 해시를 고리처럼 연결하여 일정 수의 패스워드와 해시로 이루어진 체인을 무수히 만들어 놓은 테이블이다. 해시 테이블과 R(Reduction) 함수의 반복 수행을 통해 일치하는 해시값을 통해서 패스워드를 찾아내는 방식이다.

### 버퍼 오버 플로우 공격

- 버퍼 오버플로우는 연속된 메모리 공간을 사용하는 프로그램에서 할당된 메모리의 범위를 넘어선 위치에 자료를 읽거나 쓰려고 할 때 발생한다. 버퍼 오버플로우가 발생하게 되면 프로그램의 오작동을 유발시키거나, 악의적인 코드를 실행시킴으로써 공격자가 프로그램을 통제할 수 있는 권한을 획득하게 된다.\

**스택 오버 플로우**

스택은 함수 처리를 위해 지역 변수 및 매개변수가 위치하는 메모리 영역을 말한다. 스택에 할당된 버퍼들이 문자열 계산등에 의해 정의된 버퍼의 한계치를 넘은 경우 버퍼 오버플로우가 발생하여 복귀 주소(Return Address)를 변경하고 공격자가 원하는 임의의 코드를 실행한다.

**힙 오버 플로우**

힙은 사용자가 동적으로 할당하는 메모리 영역(malloc()등의 메모리 할당 함수 이용)이다. 힙에 할당된 버퍼들에 문자열 등이 저장될 때, 최초 정의된 힙의 메모리 사이즈를 초과하면 문자열 등이 저장되는 경우 버퍼 오버플로우가 발생하여 데이터와 함수 주소등을 변경하여 공격자가 원하는 임의의 코드를 실행한다.

**버퍼 오버플로우 이해를 위한 C 언어 함수**

- **strcpy(char \*dst, const char \*src)** src 문자열을 dst 버퍼에 저장한다. src 문자열의 길이를 체크하지 않으므로 dst 버퍼를 초과하는(오버플로우) 결과가 발생할 수 있다.

  \

- **strncpy(char \*dst, const char \*src, size_t len)** src문자열의 len 만큼을 dst버퍼에 저장한다. src 문자열의 길이를 제한하기 때문에 버퍼 오버플로우에서 안전하다.

  \

- **size_t strlen(const char \*str)** 문자열(str)의 null 문자를 제외한 바이트 수를 반환한다.

  \

- **sizeif(피연산자)** 피연산자의 크기를 반환한다.

  \

**스택 버퍼 오버플로우 대응방안**

1. 안전한 함수를 사용하여 버퍼 오버플로우 방지
2. 입력값 사전 검증을 통한 버퍼 오버플로우 방지\

**스택 버퍼 오버플로우 대응기술**

1. **스택가드**: 메모리 상에서 프로그램의 복귀주소(Return Address)와 변수 사이에 특정 값을 저장해 두었다가 그 값이 변경되었을 경우를 오버플로우로 가정하여 프로그램 실행을 중단하는 기술을 말한다.
2. **스택 실드**: 함수 시작 시 복귀 주소(Return Address)를 Global RET라는 특수 스택에 저장해 두었다가 함수 종료 시 저장된 값과 스택의 RET값을 비교해 다를 경우 오버플로우로 가정하여 프로그램 실행을 중단시키는 기술을 말한다.
3. **ASLR**(Address Space Layout Randomization): 메모리 공격을 방어하기 위해 주소 공간 배치를 난수화하는 기법이다. 실행 시마다 메모리 주소를 변경시켜 악성 코드에 의한 특정 주소 호출을 방지한다.\

### 레이스 컨디션 공격

- 레이스 컨디션은 둘 이상의 프로세스나 스레드가 공유자원에 동시에 접근할 때 점근하는 순서에 따라 비정상적인(원하지 않는) 결과가 발생하는 조건/상황을 말한다.
- 실행되는 프로세스가 임시 파일을 만드는 경우 악의적인 프로그램을 통해 그 프로세스의 실행 중에 끼어들어 임시파일을 특정파일로 연결(심볼릭 링크)하여 악의적인 행위를 할 수 있는데 이를 레이스 컨디션 공격이라고 한다.
- 만약 프로세스가 setuid 설정이 되어 root 권한으로 실행된다면 권한 상승을 통해 중요자원(파일)에 접근하는 심각한 문제가 발생할 수 있다.

**레이스 컨디션 대응방안**

1. 가능하면 임시 파일을 생성하지 않는다.
2. 파일 생성 시 이미 동일한 파일이 존재하는 경우 파일 생성 또는 쓰기를 금지한다.
3. 사용하고자하는 파일에 링크가 걸려있으면 실행을 중단한다.
4. umask를 최하 022정도로 유지하여 임시로 생성한 파일이 공격자에 의해 악의적으로 삭제되지 않도록 한다.

### 포멧 스트링 공격

- 포멧 스트링은 C 언어의 printf()등의 함수에서 사용되는 문자열의 입출력 형태를 정의하는 문자열로 서식 문자열이라 표현한다.
- 포멧 스트링을 인자로 하는 함수의 취약점을 이용한 공격으로 외부로부터 입력된 값을 검증하지 않고 입출력 함수의 포멧 스트링을 그대로 사용하는 경우 발생할 수 있는 취약점이다.
- 공격자는 포멧 스트링을 이용하여 취약한 프로세스를 공격하거나 메모리 내용을 읽거나 쓸 수 있다. 그 결과, 공격자는 취약한 프로세스의 권한을 획득하여 임의의 코드를 실행할 수 있다.

**포멧 스트링의 취약점**

- 포멧 스트링을 인자로 하는 함수 사용시 포맷 스트링을 지정하지 않고 사용자의 입력을 통해서 포맷스트링이 결정된다면 공격자는 이를 조작하여 메모리 내용을 참조하고 특정 영역의 값을 변경할 수 있다.
- 가령, 공격자는 스택 프레임 구조를 고려하면서 "%x"를 통해 메모리 내용을 참조 및 원하는 위치(RET 영역)로 이동한 후 "%n"을 통해 Return Address를 악성코드가 위치한 주소로 변조하여 악성 코드를 실행할 수 있다.

**포멧스트링 대응방안**

포멧 스트링을 함수의 입력 파라미터로 직접 사용하지 않는다.

- 취약한 사용의 예

```c
#include <stdio.h>
int main(int argc, char **argv){
    printf(argv[1]);
}
```

- 안전한 사용의 예

```c
#include <stdio.h>
int main(int argc, char **argv){
    printf("%s", argv[1]);
}
```

포멧 스트링을 지정하여 간접적으로 참조가 되도록 한다.

### 크리덴셜 스터핑

무작위 대입 공격의 일종, 공격자가 미리 확보한 사용자의 로그인 자격증명을 다른 사이트의 인증 시스템에 무작위로 대입하여 접속을 시도하는 공격기법
