# 002.유닉스리눅스

## UNIX/Linux 시스템 기본

#### 시스템 접근

**로그인**

1. 사용자 계정과 패스워드를 입력하면 로그인을 담당하는 프로그램은 입력한 패스워드와 /etc/passwd 파일의 해당 필드를 비교한다.
2. 패스워드 확인 후 로그인 프로그램은 쉘이 사용할 변수들을 근거로 초기 환경을 설정한다.
   * HOME: 사용자 홈디렉터리 지정
   * SHELL: 로그인 쉘 지정
   * USER 또는 LOGNAME: 사용자의 사용자 계정 지정
3. 모든 절차가 끝나면 로그인 쉘 실행

**로그아웃**

* 유닉스 시스템에서 로그아웃을 할 때 사용하는 명령어는 `logout` 과 `exit`가 있으며 키보드의 `[Ctrl+d]` 조합키를 사용할 수도 있다.

#### 사용자 정보

**etc/passwd 파일**

* UNIX는 시스템 관리자가 사용자 계정을 만들 때마다 사용자와 관련된 정보를 /etc/passwd 파일에 저장한다.

| account | password                           | UID    | GID     | comment      | home directory           | login-shell |
| ------- | ---------------------------------- | ------ | ------- | ------------ | ------------------------ | ----------- |
| 사용자 계정명 | 사용자 패스워드(x는 shadow 패스워드를 사용한다는 의미) | 사용자 ID | 기본그룹 ID | 사용자 관련 기타 정보 | 로그인 성공 후 사용자가 위치할 홈 디렉토리 | 로그인 쉘       |

```bash
$ cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
...
ehdcjf:x:1000:1000:ehdcjf,,,:/home/ehdcjf:/bin/bash
```

* 해킹 시 주로 UID, GID를 0으로 변경한다. 시스템은 UID,GID를 기준으로 권한을 부여하기 때문에 계정 이름이 root 가 아니라도 UID, GID가 0이면 root가 되는 것이다. 이는 윈도우의 보안식별자(SID) 500이 관리자인 것과 같은 개념이다.
* UID,GID 가 0으로 변경된 계정이 있는지 주기적으로 확인해 취약점을 제거해야한다. 로그인 쉘을 변경하여 사용자 로그인 시 악성 쉘이 실행되게 하는 예도 있으므로 주기적으로 변경 여부를 확인해야한다.

**사용자 확인 `id`**

* 접속 중인 사용자를 확인하려면 id 명령을 사용한다.

```sh
$ id ehdcjf

uid=1000(ehdcjf) gid=1000(ehdcjf) groups=1000(ehdcjf),4(adm),24(cdrom),27(sudo),30(dip),46(plugdev),122(lpadmin),135(lxd),136(sambashare)
```

**패스워드 변경 `passwd`**

* 사용하던 패스워드를 변경하거나 패스워드가 없는 사용자 계정에 패스워드를 부여할때 passwd 명령을 사용한다.
* 일반 사용자는 자신의 패스워드만 변경할 수 있지만, 슈퍼 유저root는 자신을 포함하여 시스템에 등록된 모든 사용자의 패스워드를 변경할 수 있게 한다.

#### 그룹정보

**그룹명과 그룹ID**

* UNIX 시스템은 자원에 대한 접근 권한 및 보안 등의 관리를 위하여 사용자와 사용자가 소속된 그룹에 대한 식별이 필요하다.
* 사용자 ID와 그룹ID는 사용자와 그룹을 식별하는 식별자로 시스템에 유일한 정수 값으로 기술된다.

**기본 그룹과 보조 그룹**

* UNIX 시스템은 자원의 소유자가 소속된 그룹에 별도의 권한을 지정할 수 있는데, 같은 그룹에 소속된 사용자는 자원에 대하여 동일한 접근 권한을 갖는다.
* UNIX 시스템의 사용자 계정은 하나의 기본 그룹과 복수의 보조그룹에 소속될 수 있다.
* 기본 그룹은 사용자가 자원(파일 등)생성 시 해당 자원의 소유그룹을 지정하는데 사용되며 /etc/passwd 의 4번째 필드 GID 값에 명시한다.

**/etc/group 파일**

* 현재 시스템에 정의된 모든 그룹의 정보를 저장하고 있다.

| group\_name | unvariable          | group\_ID                 | user\_account\_entry\_in\_group |
| ----------- | ------------------- | ------------------------- | ------------------------------- |
| 그룹명         | 그룹의 암호화된 패스워드(사용안함) | 기본 그룹ID. 그룹명을 대신하는 정수형 숫자 | 소속된 사용자 계정들                     |

#### 입출력 재지정 (I/O Redirection)

* 입출력 대상으로 표준 입력, 표준 출력, 표준 예러를 사용하지 않고 다른 경로인 파일로 재지정 하는 것
*   키보드(표준입력:0) 에서 들어오는 입력을 파일에서 받도록 대체하는 것을 입력 재지정이라한다.

    ```sh
       $ command [0] < file_name
    ```
*   명령의 실행 결과나 에러 상황을 화면(표준출력:1, 표준에러:2)에 출력하지 않고 파일로 대체하는 것을 출력 재지정이라 한다.

    ```sh
       $ command [1 or 2] > file_name (미지정시 표준출력)

       >  # 출력 재지정(출력 파일 존재 시 새롭게 출력)
       >> # 출력 재지정(출력 파일 존재 시 추가하여 출력)
    ```

#### ~~파이프(Pipe)~~

#### ~~특수문자~~

## UNIX/Linux 파일 시스템

#### 개요

* 물리적 저장장치에 파일 생성, 저장, 관리하기 위한 논리적인 자료구조를 파일시스템이라고 한다.
* 물리적인 디스크는 논리적인 파티션으로 나누어지며, 파티션 별로 고유한 파일 시스템을 생성한다.

**파일 시스템 구성**

1. 부트블럭 운영체제를 부팅하거나 초기화하기 위한 부트스트랩 코드를 담고 있는 블럭
2. 슈퍼블럭 해당 파일시스템을 관리하기 위한 정보를 담고 있는 블럭
3. 아이노드 리스트

| 속성           | 설명                                                                                                                                                                                                   |
| ------------ | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| inode number | 파일 시스템 내에서 해당 파일을 식별하기 위한 고유 식별자                                                                                                                                                                     |
| 파일 타입        | 일반 파일, 디렉터리, 장치파일 등 파일 유형                                                                                                                                                                            |
| 접근 권한        | 파일에 대한 접근권한                                                                                                                                                                                          |
| link count   | 해당 inode를 참조하는 링크 개수(하드링크 개수)                                                                                                                                                                        |
| 소유자          | 파일의 소유자/UID                                                                                                                                                                                          |
| 소유그룹         | 파일의 소유그룹/GID                                                                                                                                                                                         |
| 파일크기         | 파일의 크기                                                                                                                                                                                               |
| MAC time     | <p>last Access Time: 파일을 마지막으로 접근한 시간<br>last Modification Time: 파일의 내용을 마지막으로 수정한 시간<br>last Change Time:파일의 속성을 마지막으로 변경한 시간. 파일의 속성을 inode정보를 의미. 즉 소유자,접근권한 등의 속성이 변경되면 last Change Time이 변경</p> |
| Block Index  | Data blocks에 저장되어 있는 파일의 내용에 대한 색인 정보                                                                                                                                                                |

* 아이노드 리스트는 파일들에 대한 속성정보를 담고 있는 inode 구조체 리스트로 이루어져 있다.
* 각 파일의 속성정보는 위와 같다. 주의할 점은 inode에는 파일명이 없으며 파일 명은 디렉토리를 통해 관리된다.
* 침해 사고가 발생하면 피해 시스템에 대한 무결성을 확인하기 위해 타임라인을 분석을 수행한다. 이때 파일시스템 inode 구조체의 MAC Time 을 점검한다.
* 특정 파일의 inode에 대한 속성정보는 stat 명령을 통해 확인할 수 있다.

4. Data blocks

* 실제 파일의 내용(데이터)이 저장되는 블럭
* 고정 크기의 블럭들로 이루어져 있다.

#### 파일 시스템과 링크 파일 `ln`

**개요**

* 링크는 윈도우의 바로가기 아이콘 처럼 기존 파일에 대한 또 다른 접근 포인트를 만들어주는 기능이다.
* 링크는 하드 링크와 심볼릭 링크로 구분할 수 있다.

| 문법 | ln \[-s] source\_file or source\_directory target\_file |
| -- | ------------------------------------------------------- |
| 옵션 | `-s` 이 옵션이 있으면 심볼릭 링크. 없으면 하드 링크                        |
| 설명 | 하드 링크는 파일에만 가능하고, 심볼릭 링크는 파일 또는 디렉토리에 링크할 수 있다.         |

**하드 링크**

* 하드 링크는 유닉스 초기 시절부터 지원해주던 방식으로 기존 파일과 동일한 inode number를 가지는 파일을 생성하여 접근하는 방식을 말한다.
* inode number는 파일 시스템 별로 고유한 값이기 때문에 동일한 파일 시스템 내에서만 하드 링크가 가능하고 디렉터리는 하드 링크가 불가능하다.
* 하드 링크 파일을 생성하면 해당 inode의 링크 카운트가 1 증가한다. 파일 삭제 시에는 링크 카운트를 1 감소시킨 후 그 값이 0이 되었을 때 해당 파일의 inode 정보 및 데이터가 삭제된다. 즉 inode를 참조하는 파일이 있으면 삭제하지 않는다.

**심볼릭 링크**

* 동일한 파일 시스템 내에서만 링크가 가능한 하드 링크의 단점을 보완
* 원본 파일에 대한 파일 경로를 파일 내용으로 하는 새로운 파일을 생성해서 접근하는 방식으로 하드링크와 달리 inode number 가 아닌 파일 경로를 기반으로 하므로 파일시스템에 제한이 없으며 디렉터리도 가능하다.
* 원본 파일이 삭제되거나 이동하게되면 해당 경로가 바뀌므로 심볼릭 링크 파일은 링크가 끊어지게 된다.

#### 디렉터리 관리

**파일의 종류**

1. 일반파일 일반적으로 데이터 또는 프로그램 코드에 해당하는 일련의 바이트 스트림으로 되어 있다. 이러한 정규 파일은 표준 파일 입출력 시스템 호출을 통해 참조된다.
2. 디렉터리 디렉터리에 포함된 파일명과 해당 파일에 대한 정보를 담고 있는 inode number 목록을 내용으로 가지고 있는 특수한 파일로 디렉터리 파일은 디렉터리의 명시적인 시스템 호출(ls)을 통해 참조된다.
3. 특수 파일 특수 파일은 기능에 따라서 다양한 형태로 존재하며 표준 입출력 시스템 호출을 통해 참조된다.
   * 프로세스 간 통신(IPC)를 위해 파이프(pipe), 소켓(socket) 등의 파일을 사용한다.
   * 디스크, 프린터, 터미널, 키보드 등의 주변장치를 사용하기 위한 장치파일로 블럭 단위로 입출력하는 블록 장치파일(버퍼링)과 문자단위로 입출력하는 문자 장치파일(비 버퍼링)로 구분한다.

**ls**

* 파일의 종류

| 문자값 | 디렉터리 및 파일의 종류 |
| --- | ------------- |
| d   | 디렉터리          |
| b   | 블록 장치 파일      |
| c   | 문자 장치 파일      |
| l   | 심볼릭 링크 파일     |
| p   | 네임드 파이프       |
| s   | 유닉스 도메인 소켓    |
| -   | 일반(정규) 파일     |

~~**cd**~~

~~**mkdir**~~

~~**rmdir**~~

## UNIX/Linux 파일 관리

#### ~~접근 권한 변경 `chmod`~~

#### ~~소유주/소유그룹 변경 `chown`/`chgrp`)~~

#### 접근 권한 마스크`umask`

* umask 명령은 앞으로 만들어질 파일에 영향을 미치는 명령으로, 명령 시 지정한 8진수는 새로 만들어질 파일에서 제거될 권한을 명시한다.
* 일반 파일을 생성할 때 접근권한은 666에서 umask 로 지정한 값을 빼고, 디렉터리의 경우 777에서 umask 로 지정한 값을 빼게 된다.
* 시스템 관리자는 /etc/profile 파일에 umask를 지정하여 시스템 전체 사용자에게 획일적인 umask 값을 적용할 수 있다.

#### ~~UNIX/Linux 파일 검색 `find`~~

## UNIX/Linux 프로세스

#### 프로세스 개요

* 프로세스가 생성되면 커널/운영체제는 개별 프로세스 관리정보를 담고 있는 프로세스 제어 블록(PCB: Process Control Block)을 생성
  * 프로세스 상태 (Process state): 프로세스의 현재 상태 정보를 저장(ready, running, blocked 등)
  * 프로세스 번호(Process number): 프로세스를 식별하기 위한 번호(ID)
  * 프로그램 카운터(Program counter): 문맥교환이 발생할 경우 다음에 실행할 명령어의 위치 값을 저장
  * 레지스터(Registers): 문맥교환이 발생한 경우 현재 프로세스의 실행 상태 정보(레지스터 정보)를 저장
  * 메모리 정보(Memory limits): 프로세스가 사용하는 메모리 page 또는 segment 테이블 정보
* 프로세스가 생성되면 개별 프로세스별로 오픈한 파일을 관리하기 위한 파일 디스크립터 테이블(FDT:File Descriptor Table)이 생성된다.
  * 기본적으로 3개의 파일이 자동 오픈된다. 표준 입력(stdin)은 표준 입력장치로부터 입력을 의미하고, 표준출력(stdout)은 표준 출력장치(모니터)로의 출력을 의미하고, 표준에러(stderr)은 오류 발생시 출력을 의미한다.
  * 프로세스 내에서 오픈한 각각의 파일을 식별하기 위한 양의 정수 값을 파일 디스크립터라고한다.
* 커널/ 운영체제가 시스템 내에서 여러 프로세스에 의해 오픈된 파일들을 관리하기 위한 자료구조가 System open-file tables이다.
  * open-mode: 파일의 읽기/쓰기 모드
  * offset: 현재 파일 I/O를 수행하기 위한 위치값(Position)
  * reference\_count: 해당 파일의 참조 개수를 의미. 파일 복제(dup) 가 발생하게 되면 reference\_count가 증가
* Active vnode table은 해당 파일의 inode 정보를 가지고 있는 일종의 캐시 역할을 한다. 즉, 다양한 파일시스템의 inode 정보를 관리하기 위한 중계자 역할을 한다.

#### 프로세스 기본 조건

* fork() 함수는 자식 프로세스를 생성하는 시스템 함수
* pid(프로세스 ID), ppid(부모 프로세스 ID)
* 모든 프로세스는 부모 프로세스를 가진다.
  * 시스템 부팅을 담당하는 boot 프로세스(0번 프로세스)를 제외한 모든 프로세스는 부모 프로세스를 가진다.
  * 자식 프로세스가 살아있는 상태에서 부모 프로세스가 종료되면 자식 프로세스는 고아 프로세스가 되며, 이 경우 대리모 프로세스(pid가 1인 init process)가 부모 역할을 한다.
* 프로세스 종료 시에는 자신의 종료상태정보를 부모 프로세스에 반환해야 정상적으로 소멸할 수 있다.
  * 종료 상태 정보는 자신의 pid, exit code(종료시 반환하는 값), cpu time(cpu 사용시간) 등의 정보를 말한다.
  * 프로세스 수행을 종료했지만 부모 프로세스가 종료 상태 정보를 확인하지 않아서 소멸하지 않고 남아 있는 상태의 프로세스를 좀비 프로세스라 한다. 시스템/커널 입장에서 프로세스는 제한된 자원이므로 좀비 프로세스가 과도하게 많아지면 더 이상 프로세스를 생성하지 못하는 문제가 발생할 수 있다.
*   ps -l 의 주요 필드의 의미는 다음과 같다.

    | 필드명   | 설명                                                                                                                                                                                                        |
    | ----- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
    | F     | PROM(Programmable Read-Only Memory) 모드                                                                                                                                                                    |
    | S     | <p>프로세스의 현재 상태<br>R: 프로세스가 실행중이거나 CPU를 점유하기 위해 대기 (Runnable/Ready) 중인 상태<br>S: 인터럽트가 가능한 Sleep 상태<br>D: 인터럽트가 불가능한 Sleep 상태 (일반적으로 IO 대기 중 상태)<br>T: 프로세스가 정지된 상태(Stopped)<br>Z: 좀비 상태의 프로세스 (Zombie)</p> |
    | PRI   | 프로세스의 우선순위(낮을수록 우선순위 높음)                                                                                                                                                                                  |
    | NI    | 프로세스의 우선순위를 계산할 때 사용하는 값 (Nice Value)                                                                                                                                                                     |
    | ADDR  | 프로세스의 메모리 주소                                                                                                                                                                                              |
    | SZ    | 프로세스가 차지하는 메모리 크기                                                                                                                                                                                         |
    | WCHAN | Sleeping 상태의 프로세스가 대기하는 커널 함수 명                                                                                                                                                                           |

#### 프로그램 실행 과정

//// 그림 추가 필요

* 프로세스 생성과 동시에 프로세스 그룹도 생성된다.
  * 프로세스 그룹은 커널이 터미널 제어권을 관리하기 위한 목적으로 사용하는 프로세스들의 집합으로 쉘에서 실행된 프로세스와 그 자식 프로세스들이 하나의 프로세스 그룹으로 관리된다.
  * 터미널 제어권이랑 터미널로부터 입력되는 데이터와 터미널로부터 발생한 시그널에 대한 제어권으로 프로세스 그룹 단위로 제어권이 부여된다.
  * 커널이 프로세스 그룹을 식별하기 위한 식별자로 PGID를 부여하며, PGID는 별도로 부여하는 식별자가 아니고 해당 그룹의 리더 프로세스(쉘로부터 실행된 프로세스)의 PID를 PGID 로 설정한다.

\


* 포그라운드 백그라운드
  * 터미널에 대한 제어권을 가지고 동작하는 모드를 포그라운드 모드라고 하며, 제어권을 가지고 있는 프로세스 그룹을 포그라운드 프로세스 그룹이라 한다.
  * 터미널에 대한 제어권 없이 동작하는 모드를 백그라운드 모드라고 하며, 제어권이 없는 프로세스 그룹을 백그라운드 프로세스 그룹이라 한다.
  * 터미널과 연결되어 세션이 생성되면 해당 세션 내에서는 하나의 포그라운드 프로세스 그룹과 하나 이상의 백그라운드 프로세스 그룹이 생성된다.

#### 프로세스 관련 식별자

* Process ID(PID): 시스템/커널 내에서 프로세스를 식별하기 위한 고유 ID
* Parent Process ID(PPID): 부모 프로세스를 식별하기 위한 ID
* Process Group ID(PGID): 프로세스 그룹을 식별하기 위한 ID
  * 모든 프로세스는 생성과 동시에 하나의 프로세스 그룹에 속하게 되며, pgid는 해당 프로세스 그룹의 리더 프로세스의 pid가 된다.
* Session ID(SID): 세션을 식별하기 위한 ID
  * 터미널과의 논리적인 연결 상태를 세션이라고 하며, 세션 내에는 다수의 프로세스 그룹과 프로세스 그룹에 속하는 프로세스들이 존재한다.
  * sid는 해당 세션의 리더 프로세스(일반적으로 로그인 쉘) pid 가 된다.

#### 프로세스 정보 확인 `ps`

*   시스템에 상주하는 프로세스의 정보를 알려준다.

    | 문법 | ps \[-flaAe] \[-G gid\_list] \[-g egid\_list] \[-U uid\_list] \[-u euid\_list] \[-t terminal\_list]                                                                                                                                                                                                                                                    |
    | -- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
    | 옵션 | <p><code>-f</code> 이 옵션을 사용하면 프로세스 정보가 한줄씩 다음처럼 출력된다.<br>UserName PID PPID C STIME TTY TIME CMD<br><code>-l</code> 이 옵션은 <code>-f</code>옵션보다 더 많은 정보를 출력하며 다음과 같은 형식을 따른다.<br>F S UID PID PPID C PRI NI ADDR SZ WCHAN TTY TIME CMD<br><code>-a</code> 최근에 많이 실행된 제어 터미널을 가진 프로세스의 정보를 출력한다.<br><code>-A,-e</code> 현재 시스템에서 실행 중인 모든 프로세스 정보를 출력한다.</p> |
    | 예문 | $ `ps -ef` # 모든 프로세스를 보여주고, 다양한 정보를 한줄씩 출력 (가장 많이 사용됨)                                                                                                                                                                                                                                                                                                 |

\


* ps -ef

|       |                                              |
| ----- | -------------------------------------------- |
| UID   | User ID, 프로세스의 EUID(Effective User Id)       |
| PID   | Process ID                                   |
| PPID  | Parent Process ID                            |
| C     | 프로세스 스케줄링을 위한 CPU 사용량                        |
| STIME | Start Time, 프로세스가 시작된 시간(월일시분초)              |
| TTY   | 프로세스와 연결된 터미널 타입 `?`는 제어 터미널에 연결되어 있지 않음을 의미 |
| TIME  | CPU 사용 시간으로 "시:분" 형식으로 표현                    |
| CMD   | 프로세스 명                                       |

\


#### 프로세스간 통신(시그널)

* UNIX 시스템은 다양한 종류의 프로세스 간 통신 방법을 지원한다. (파이프, 시그널, 메시지큐, 공유메모리, 세마포어)
* 시그널은 UNIX 시스템에서 지원하는 소프트웨어 인터럽트다. 이를 이용하여 프로세스는 다른 프로세스에 이벤트를 전달할 수 있으며 전달된 이벤트를 프로세스 간 통신 수단으로 사용할 수 있다.
*   시그널이 발생하는 경우는 외부에 의해서, 에러에 의해서, 이벤트에 의해서, 인위적으로 네 가지 이다.

    |        |                                  |
    | ------ | -------------------------------- |
    | 에러상황   | 커널                               |
    | 외부상황   | 키보드 입력                           |
    | 이벤트 발생 | alarm() 함수, 프로세스 종료              |
    | 인위적 발생 | kill()함수 (System Call), kill 명령어 |

    | 문법 | <p>kill [-signal_number or -signal_name] PID<br>kill -l [signal]</p>                                                  |
    | -- | --------------------------------------------------------------------------------------------------------------------- |
    | 옵션 | <p><code>-signal_number or -signal_name</code> 시그널 번호 또는 시그널 명(SIG 생략)<br>Us <code>-l</code> 지원 가능한 시그널 목록을 출력한다.</p> |
    | 예문 | <p>$ <code>kill -9 3000</code><br>$ <code>kill -KILL 3000</code></p>                                                  |
    | 설명 | 시그널 옵션이 생략된 경우 SIGTERM 시그널이 발생한다.                                                                                     |

\


*   주요 시그널 UNIX/SunOS 기준

    | 시그널 명   | 번호 | 의미                                                                                              |
    | ------- | -- | ----------------------------------------------------------------------------------------------- |
    | SIGNIT  | 2  | `[Ctrl+c]` 조합키를 누르면 포그라운드 프로세스 그룹 내 모든 프로세스에게 이 시그널이 전달된다. 이 시그널을 받은 프로세스는 디폴트로 종료된다.           |
    | SIGKILL | 9  | 무시하거나 임의로 처리될수 없는 시그널로, 이 시그널을 받은 프로세스는 종료된다.                                                   |
    | SIGSTOP | 23 | 프로세스를 정지시키는 프로세스 제어 시그널이며 무시하거나 임의로 처리할 수 없다.                                                   |
    | SIGTERM | 15 | 이 시그널을 받은 프로세스는 디폴트로 종료된다.                                                                      |
    | SIGFPE  | 8  | 커널에 의해 발생한 산술연산에러(0으로 나누기 등)를 내느 프로세스에게 이 시그널이 전달된다.                                            |
    | SIGCHLD | 18 | 프로세스의 종료나 정지의 경우 부모 프로세스에게 이 시그널이 전달된다.                                                         |
    | SIGALRM | 14 | alarm() 함수가 설전된 타이머에 의해 발생한다.                                                                   |
    | SIGQUIT | 3  | `[Ctrl+\]`조합키를 누르면 전위 프로세스 그룹 내 모든 프로세스에게 이 시그널이 전달된다. 이 시그널을 받은 프로세스는 디폴트로 종료되며 Core 파일을 생성한다. |
    | SIGSEGV | 11 | 커널에 의해 발생하며 잘못된 메모리를 참조하는 프로세스에게 이 시그널이 전달된다.                                                   |
    | SIGHUP  | 1  | 터미널 연결이 끊어지는 경우에 프로세스에게 이 시그널이 전달된다. 최근에는 환경 설정 파일의 재설정에 사용된다.                                  |

\


## UNIX/Linux 시스템 관리

#### 부팅 관련 용어 정리

**런 레벨**

* 시스템의 런 레벨의 의미는 시스템의 운영 상태를 숫자 혹은 문자로 표현한 것이다.
* init 프로세스는 /etc/inittab 파일에 정의된 런 레벨에 따라 /etc/rc.d/rc\[x].d(여기서 \[x]는 런레벨) 디렉터리에 나열된 스크립트를 실행하여 시스템의 운영 상태를 구성한다.
* 각 런 레벨이 의미하는 시스템의 운영 상태는 일반적으로 다음과 같다.

| 런레벨 | 시스템의 운영 상태                             |
| --- | -------------------------------------- |
| 0   | PROM(Programmable Read-Only Memory) 모드 |
| S,s | 시스템 싱글 유저 모드, 로컬 파일시스템이 마운트되지 않은 상태    |
| 1   | 시스템 싱글 유저 모드, 로컬 파일시스템이 마운트된 상태        |
| 2   | 멀티 유저 모드(NFS 클라이언트 모드)                 |
| 3   | 멀티 유저 모드(NFS 서버 모드), UNIX 기본 Run Level |
| 4   | 사용 안함                                  |
| 5   | 시스템 power off 모드                       |
| 6   | 시스템 리부팅                                |

* 서버용 UNIX 시스템은 일반적으로 3 또는 5의 런 레벨로 운영된다. 현재 운영 중인 시스템의 런 레벨을 알고 싶은 경우 who -r 또는 runlevel 명령을 사용한다.

**INIT 상태**

* INIT 상태란 런 레벨과 같은 의미이다. 시스템이 런 레벨을 이동할 때, init 명령어를 통해서 이동한다.
* 예를 들어 현재 런 레벨이 멀티 유저 모드인 3번인다. 싱글 유저 모드로 이동하고 싶으면 "init S" 명령어를 이용하면 된다.\


**시스템 런 레벨 단계 구성**

// 추후 업데이트

#### 시스템 시작

1. 바이오스 과정
   * 시스템 전원이 들어오면 바이오스는 시스템의 기본적인 하드웨어(CPU, 메모리 등)의 이상 유무를 점검하고 시스템의 하드웨어 정보를 수집한다.
2. 부트 프로그램 과정
   * 부트 프로그램은 하드 디스크에서 커널을 읽어 들여 메모리 상에 적재하고 시스템 제어권을 커널에 넘긴다.
3. 커널 과정
   * 커널이 메모리상에 적재되면 그때부터 운영체제가 구동되기 시작한다.
   * 커널은 부팅 과정의 일부인 하드웨어 점검을 완료하고 내부 자료구조를 초기화하여 시스템을 운영하기 위한 부가적인 커널 모듈을 하드 디스크에서 메모리 상으로 적재한다.
4. init 프로세스 과정
   * init 프로세스는 커널에 의해 생성되는 첫번째 프로세스이다. 커널의 실행으로 운영체제가 하드웨어의 모든 기능을 제어하게 되었을 때 PID 가 1 인 init 프로세스가 실행된다.
   * 이 프로세스는 모든 UNIX 프로세스의 부모 프로세스로서, 부팅 과정에서 사용자가 시스템을 사용할 수 있게 해주는 초기화 작업을 담당한다.
   * BSD 계열은 싱글 유저 모드와 멀티 유저 모드 두 가지를 지원하는 데 반하여, system V 계열은 더 많은 단계로 시스템의 운영 상태를 분류한다. 이를 런 레벨이라 한다.

#### 시스템 종료

* 운영 중인 UNIX 시스템은 정기 점검, H/W 및 S/W의 추가 또는 변경, 기타 관리 작업을 하기 위하여 시스템의 종료가 필요하다.
* UNIX 시스템 종료 시 주의사항
  * 접속 중인 사용자에게 시스템의 종료를 공지하여 작업을 마무리하도록 해야한다.
  * 운영 중인 서비스를 안전하게 종료해야 한다.
  * 하드 디스크를 갱신하여 파일 시스템의 무결성을 유지한다.
* shutdown 명령은 시스템을 안전하게 종료할 때 사용하며 시스템의 런레벨을 변경할 때도 사용한다. 이 명령은 System V 계열과 BSD 계열로 구분된다.
* 하드디스크 동기화
  * UNIX 시스템은 하드 디스크의 입출력에 대한 효율성을 높이기 위해 버퍼를 운영한다.
  * 만일 시스템이 비정상적으로 종료되면 버퍼에 있는 데이터가 하드 디스크에 반영되지 않아서 파일시스템에서 무결성 문제가 생긴다. 따라서 하드 디스크 동기화는 시스템을 종료하는 중에 해야 할 가장 중요한 작업이다.
  * 유닉스나 리눅스 종료 시 sync 명령을 내리는 이유가 바로 버퍼의 내용을 하드 디스크로 옮기기 위함이다.

#### 사용자 관리

**사용자 계정 추가 `useradd`**

* UNIX 시스템에 새로운 사용자 계정을 추가하는 과정은 다음과 같다.
  * 사용자 계정 정보를 저장하는 "/etc/passwd"와 암호화된 비밀번호를 저장하는 "/etc/shadow"에 사용자 정보를 추가한다.
  * 그룹 파일 "/etc/group"에 그룹 정보를 추가한다.
  * 새 사용자를 위한 홈 디렉터리를 생성하고 접근권한을 부여한다.
  * 사용자 로글인 시 필요한 몇 가지 시작 파일을 홈 디렉터리에 생성한다.

**사용자 계정 삭제`userdel`**

**그룹 추가`groupadd`**

* 옵션: `-g gid`: 새로운 그룹에 할당할 그룹의 GID를 명시적으로 지정

**그룹 삭제`groupdel`**

#### 파일 시스템 관리

**파일시스템 연결 `mount`**

* 보조기억장치에 들어 있는 데이터를 읽어오고, 여기에 저장하려면 먼저 해당 장치를 UNIX 시스템에 연결하는 작업이 필요하다.
* mount 명령은 보조기억장치에 설치된 파일 시스템을 UNIX 시스템이 인식하도록 특정 디렉터리에 논리적으로 연결해준다.

| 문법 | <p>mount [-option] [device ! mount_point]<br>mount [-option] device mount_point</p>                                        |
| -- | -------------------------------------------------------------------------------------------------------------------------- |
| 옵션 | `-a` /etc/fstab 파일에 정의된 모든 파일시스템을 마운트                                                                                      |
| 예문 | <p>$ mount -a # /etc/fstab 파일을 기반으로 명시적으로 실행<br>$mount /dev/cdrom /mnt/cdrom #/dev/cdrom 디바이스 파일을 /mnt/cdrom 디렉터리에 마운트</p> |
| 설명 | 인수의 지정 없이 mount 명령만 사용하면 현재 시스템에 마운트된 정보를 출력한다.                                                                            |

**파일시스템 연결 해제 `unmount`**

* umount 명령은 이전에 마운트된 파일시스템의 연결을 해제한다.
* 프로세스가 파일 시스템에 있는 파일을 사용중이거나 사용자가 파일시스템에 잇는 디텍터리에 있다면 umount 명령은 `device is busy` 메시지와 함께 실패한다.
* /etc/mtab 파일은 시스템에 마운트된 파일시스템의 정보를 관리한다. mount 명령을 실행하면 파일 시스템이 마운트 정보를 /etc/mtab 파일에 기록하고, umount 명령은 정보를 삭제한다.

| 문법 | unmount \[-option] \[device ! mount\_point]                                                                  |
| -- | ------------------------------------------------------------------------------------------------------------ |
| 옵션 | <p><code>-a</code> 마운트된 모든 파일시스템을 언마운트<br><code>-f</code> 해당 파일 시스템을 사용하는 프로세스를 강제로 종료하고 파일시스템을 언마운트 한다.</p> |
| 예문 | <p>$ unmount -a # 마운트된 모든 파일시스템을 언마운트한다.<br>$ unmount /mnt/cdrom # /mnt/cdrom 디렉터리에 연결된 파일시스템의 연결을 끊는다.</p>  |
| 설명 | 언마운트 대상인 디바이스 파일 또는 마운트 포인트를 지정한다. 루트 디렉터리 / 는 언마운트 할 수 없다.                                                  |

**하드 디스크 사용량 `du`**

* disk usage
* 디렉터리의 하드 디스크 사용량을 확인하는데 사용한다. | 문법 | du \[-option] \[derectory\_name] | | ---- | --------------------------------------------------------------------------------- | | 옵션 | `-a` 디렉터리뿐만 아니라 하위의 파일에 대한 정보도 보여준다. All\
  `-s` 현재 디렉터리가 차지하는 총 용량만 출력한다. Summary\
  `-k` 사용량을 킬로바이트 단위로 환산하여 출력한다. | | 설명 | derictory\_name 인수를 사용하지 않으면 현재 디렉터리를 기준으로 한다. |

**파일 시스템 용량 정보 `df`**

* disk free
* 파일 시스템의 전체 공간 및 사용 가능 공간에 대한 정보를 보여준다.

| 문법 | df \[-option] \[file\_system or file]                                                                         |
| -- | ------------------------------------------------------------------------------------------------------------- |
| 옵션 | <p><code>-i</code> 파일시스템의 사용 가능한 또는 사용중인 inode 정보를 출력한다.<br><code>-k</code> 통계 데이터를 1024Byte 블록 단위로 출력한다.</p> |
| 설명 | file\_system 인수는 파일 시스템이 있는 장치명 또는 파일 시스템이 마운트된 디렉터리를 의미한다. file 인수는 일반 파일 또는 디렉터리를 의미한다.                     |

#### 정기적 스케줄 관리 cron

**cron**

* cron 데몬 프로세스는 시스템에서 정기적인 작업을 지정시간에 처리하기 위해 사용한다. cron에 의해 동작하는 서비스를 주기적으로 확인하여 임의의 서비스가 동작하는 것을 예방해야 한다.
* cron 데몬 프로세스를 통한 처리가 효율적인 작업은 다음과 같은 특징을 갖는다.
  * 일괄적으로 처리해야하는 작업(특히 몰아서 하는 야간작업)
  * 작업에 대한 요구가 불규칙하지 않은 경우
  * 우선순위가 낮은 작업을 일정한 시기에 처리해야하는 경우
  * 작업 빈도가 낮아서 필요 시점에 처리하여 마무리하는 것이 자원 관리상 효율적인 경우
* cron 데몬 프로세스를 사용하려면 다음 세 가지 구성요소가 필요하다.
  * 정기적으로 처리할 작업 목록을 정의한 crontab파일
  * crontab파일을 제어하는 crontab 명령
  * crontab 파일을 읽어서 내용에 정의된 대로 작업을 처리하는 cron 데몬 프로세스
* cron 데몬 프로세스는 시스템에서 기본적으로 지원하는 데몬 프로세스이므로 사요자는 crontab 명령으로 작업목록을 정의하는 방법만 이해하면 된다.

\


**crontab 파일의 구조**

| 필드  | 의미 | 기술방법                                                        |
| --- | -- | ----------------------------------------------------------- |
| 필드1 | 분  | 0-59                                                        |
| 필드2 | 시  | 0-23                                                        |
| 필드3 | 일  | 1-31                                                        |
| 필드4 | 월  | 1-12                                                        |
| 필드5 | 요일 | 0-6 까지의 숫자로 기술, 일요일이 0                                      |
| 필드6 | 작업 | <p>지정한 시간에 실행할 작업을 절대 경로로 기술하고<br>필요한 옵션 및 인수를 함께 나열한다.</p> |

* `*` 기호는 각 필드 범위에 해당하는 모든 값을 의미한다.
* `-` 기호는 값의 범위를 기술할 때 사용한다.
* `,` 기호는 값을 구분하여 기술할 때 사용한다.
* `/` 기호는 간격값을 지정할 때 사용한다.

| 예                                      | 설명                                                            |
| -------------------------------------- | ------------------------------------------------------------- |
| 0 1 \* \* \* batch.sh                  | 매일 01시에 batch.sh 실행                                           |
| 0 8-10 \* \* \* batch.sh               | 매일 8시, 9시, 10시에 batch.sh 실행                                   |
| 0 1,2,5 \* \* \* batch.sh              | 매일 1시,2시,5시에 batch.sh 실행                                      |
| \*/5 \* \* \* \* batch.sh              | 매 5분 간격으로 batch.sh 실행                                         |
| 20 6 \* \* 1-5 /work/batch\_job param1 | 매월 매일 월\~금요일 오전 6시 20분에 /work/batch\_job 명령을 param1 인수와 함께 실행 |
| 10 3 \* \* \* /usr/sbin/logadm         | 매일 새벽 3시 10분에 /usr/sbin/logadm 명령어 실행                         |

\


**crontab 파일의 제어**

* crontab 파일을 사용자 계정별로 만들어진다.
* 시스템 관리자인 root 는 사용자를 명시적으로 지정하여 다른 사용자의 crontab 파일을 편집할 수 있으며, 일반 사용자는 자신의 crontab 파일만 편집할 수 있다.

| 문법 | <p>리눅스: crontab [-u user] [-e] -l or -r<br>유닉스: crontab [-e] -l [-r] [user]</p>                                                    |
| -- | ---------------------------------------------------------------------------------------------------------------------------------- |
| 옵션 | <p><code>-e</code> crontab 파일을 편집한다.Edit<br><code>-l</code> crontab 파일을 출력한다. List<br><code>-r</code> crontab 파일을 삭제한다. Remove</p> |
| 설명 | 사용자 계정을 명시하지 않으면 자신의 계정을 의미한다.                                                                                                     |

\


**crontab 명령 접근제어**

* crontab 명령을 싱행할 수 있는 사용자를 제한하여 허용하지 않는 사용자가 임의로 crontab 명령을 통한 작업 등록을 못하도록 설정한다.
* crontab 명령 접근 제어를 위해 /etc/cron.allow, /etc/cron.deny 설정 파일을 사용한다.
* cron.allow 파일만 존재할 경우, 해당 파일에 등록되어 있는 사용자만이 crontab 명령을 실행할 수 있다. (화이트리스트 방식)
* cron.deny 파일만 존재할 경우 해당 파일에 명시된 사용자를 제외하고 모든 사용자가 crontab 명령을 실행할 수 있다. (블랙리스트 방식)
* cron.allow, cron.deny 파일이 모두 존재하는 경우 cron.allow 파일이 우선하여 해당 파일에 등록된 사용자만이 crontab 명령을 실행할 수 있다.
* cron.allow, cron.deny 파일이 모두 없는 경우 대부분 시스템에서 root만이 crontab 명령을 실행할 수 있다. 일부시스템에서는 모든 사용자에게 실행 권한을 준다.

\


#### 일시적 스케줄 관리 `at`

* 작업을 정기적으로 스케줄링하는 cron 데몬 프로세스와 달리 at 명령은 정해진 시간에 한 번만 실행한다.
* 작업은 예약 시간에 처리되고, 한번 처리된 작업은 작업 목록에서 삭제된다.

| 문법 | at \[-l] \[-t] time\_date                                                                                                                                                                                                    |
| -- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 옵션 | <p><code>-t time_date</code> 작업시간을 지정한다.(UNIX)<br><code>-l</code> 현재 대기중인 작업 목록을 출력한다. List<br><code>-r job_id</code> job_id 에 해당하는 작업을 목록에서 삭제한다. (UNIX)<br><code>-d job_id</code> job_id 에 해당하는 작업을 목록에서 삭제한다. (Linux)</p> |
| 설명 | <p><code>atq</code>: at -l 과 같은 기능으로 작업목록을 출력한다.<br>atrm job_id: job_id에 해당하는 작업을 목록에서 삭제한다.</p>                                                                                                                             |

\


## UNIX/Linux 서버 시스템 보안

#### 사용자 패스워드 관리

* 사용자 관리란 UNIX/Linux 시스템을 이용하는 사용자 계정과 인증을 관리하는 것을 말한다.
* passwd파일은 시스템에 등록된 사용자 정보가 담겨 있다. 패스워드 저장 정책에는 passwd(/etc/passwd) 파일 내 계정 정보와 함께 저장하는 일반 패스워드 정책과 shadow(/etc/shadow) 파일에 패스워드를 별도로 저장하는 shadow 정책이 있다.
* 과거에는 사용자의 패스워드를 passwd 파일의 두번째 필드에 저장했다. 하지만 최근 UNIX/Linux 시스템에서는 shadow 파일에 암호화된 패스워드를 저장하고 root 만이 접근할 수 있도록 제한하여 패스워드 보안을 강화하고 있다.

**passwd(/etc/passwd)**

| \[user\_account]: | \[user\_password]: | \[user\_id]: | \[group\_id]: | \[comment]: | \[home\_directory]: | \[login\_shell] |
| ----------------- | ------------------ | ------------ | ------------- | ----------- | ------------------- | --------------- |
| 1                 | 2                  | 3            | 4             | 5           | 6                   | 7               |

1. **user\_account**: 사용자 계정명, root 계정은 시스템에 대한 총괄 권한을 가지고 있는 계정으로 공격자의 목표가 될 수 있으므로 원격 접속을 금지하는 것이 보안상 안전하다. 일반적으로 root 계정으로 su 명령을 허용하는 계정 그룹을 생성한 수 해당 계정으로 접속 후 root 계정으로 전환하여 su명령을 사용한다.
2. **user\_password**: 사용자 패스워드, x의 의미는 shadow 패스워드를 사용한다는 의미이다.
3. **UID**: 사용자 아이디, root(관리자) 계정의 경우 0으로 부여된다. UID는 중복되어 사용될 수 있으며 동일한 UID가 부여된 계정은 계정명이 달라도 동일한 권한을 부여받는다. 따라서 임의로 생성된 계정에 UID가 0으로 부여되어 있다면 이는 root 권한 탈취를 위한 행위로 의심해야한다.
4. **GID**: 사용자 기본 그룹 아이디, root 그룹의 경우 0으로 부여한다. GID도 UID와 동일하게 중복되어 부여될 수 있으므로 임의로 생성된 그룹에 GID가 0으로 부여되어 있는지 점검해야한다.
5. **comment**: 설명, 사용자 관련 기타 정보로 일반적으로 사용자 이름을 설정한다.
6. **home\_directory**: 홈 디렉터리, 로그인에 성공한 수에 사용자가 위치할 홈 디렉터리로 root계정은 /root 디렉터리를 사용하며 일반 사용자는 /home 디렉터리 하위에 위치한다.
7. **login\_shell**: 로그인 쉘, 리눅스의 경우 기본 쉘로 bash쉘을 사용한다. 로그인이 불필요한 계정에 대해서는 로그인을 금지하는 것이 보안상 안전하다. 로그인이 불필요한 시스템 계정 및 애플리케이션 계정에 대해서는 로그인을 금지하여 공격자에 의한 불법적인 시스템 접근이 이루어지지 않도록 해야한다. 해당 계정의 로그인 쉘을 "/sbin/nologin" 또는 "/bin/false"로 설정한다.

**shadow(/etc/shadow)**

* 패스워드 정보를 평문으로 저장할 경우 정보 유출 피해가 발생할 수 있으므로 패스워드를 암호화하여 보호해야 한다. shadow 패스워드를 사용하여 "/etc/shadow" 파일에 암호화된 패스워드가 저장되도록 하고 관리자만이 읽을 수 있도록 제한해야 한다. 일반적으로 shadow 파일의 경우 root 만 읽을 수 있도록 기본 접근 권한이 설정되어 있다.
*   shadow 파일에는 계정 별 암호화된 패스워드 정보와 패스워드 에이징 정보가 저장되어 있다. 패스워드 에이징 정보는 시간의 흐름에 따른 패스워드 관리 정책을 말한다.\


    | \[user\_account]: | \[encrypted\_password]: | \[last\_change]: | \[minlife]: | \[maxlife]: | \[warn]: | \[inactive]: | \[expires] |
    | ----------------- | ----------------------- | ---------------- | ----------- | ----------- | -------- | ------------ | ---------- |
    | 1                 | 2                       | 3                | 4           | 5           | 6        | 7            | 8          |

1. user\_account: 사용자 계정명
2. encrypted\_password: 암호화된 패스워드
3. last\_change: 마지막으로 패스워드를 변경한 날(1970.01.01 기준으로 일수로 표시)
4. minlife: 패스워드 최소 사용기간 설정. 패스워드를 마지막으로 변경한 날 이후부터 패스워드를 변경할 수 없는 일수를 의미. 1일(1주)가 권장됨.
5. maxlife: 패스워드 최대 사용기간 설정. last\_change 이후부터 패스워드 만료 일수를 의미. 90일(12주)가 권장
6. warn: 패스워드 만료 이전 경고 일수를 의미
7. inactive: 패스워드 만료된 이후 계정이 잠기기 전까지 비활성 일수로 해당 비활성 기간에 패스워드를 변경하지 않으면 계정이 잠기게 된다. UNIX 계열에서는 마지막 로그인 이후 해당 비활성 일수 동안 로그인하지 않으면 계정을 잠근다는 의미로 Linux와 차이가 있다.
8. expires: 계정 만료일 설정으로 1970.01.01 기준으로 일수로 표시한다.

\


* encrypted\_password
  * encrypted\_password 필드는 "$**ID**$**Salt**$**encrypted\_password**"형식으로 구성되어 있다.
  * **ID** 는 암호화에 적용된 일방향 해시 알고리즘을 식별하기 위한 ID로 1:MD5, 2:BlowFish, 5:SHA-256, 6:SHA-512를 의미한다. 최근에는 MD5가 더 이상 안전하지 않기 때문에 SHA-256 이상의 해시 알고리즘이 권장된다.
  * **솔트** 는 패스워드 암호화 강도를 높이기 위한 임의의 값으로 사용자가 지정한 패스워드에 서로 다른 솔트를 추가하여 암호화된 패스워드(해시값)을 생성한다. 동일한 패스워드를 사용하더라도 서로 다른 솔트에 의해서 실제 암호화된 패스워드는 서로 다른 것을 볼 수 있다.
  * 솔트를 통해 레인보우 테이블 공격에 효과적으로 대응할 수 있다. 그 이유는 레인보우 테이블 공격을 통해 암호화된 패스워드(해시값)의 평문 패스워드를 알아낸다고 해도 이는 솔트와 조합된 패스워드 해시값에 대한 평문 패스워드로 실제 패스워드락 아니다. 따라서 크랙된 평문 패스워드로 로그인을 시도하면 패스워드 검증 시 입력한 패스워드 솔트를 조합한 해시 값을 비교하기 때문에 로그인에 실패하게 된다.
  * **encrypted\_password** 는 사용자 패스워드에 솔트를 조합하여 해시한 해시값, 즉 암호화된 패스워드를 말한다.
  *   **encrypted\_password** 필드에 특수기호나 빈 값으로 남아있는 경우가 있다. 그 의미는 다음과 같다.

      | 기호 | 설명                                                                           |
      | -- | ---------------------------------------------------------------------------- |
      | \* | 패스워드가 잠긴 상태로 패스워드 로그인은 불가하지만, 별도의 인증 방식을 사용하여(e.g. SSH 인증키)로그인 가능            |
      | !! | 패스워드가 잠긴 상태로 모든 로그인이 불가능하다. 기본적으로 사용자 계정을 생성하고 패스워드를 설정하지 않으면 !!로 되어 있다.     |
      | 빈값 | 패스워드가 설정되지 않은 상태이다. 패스워드가 설정되어 있지 않으면 패스워드 없이 로그인 할 수 있으므로 패스워드를 반드시 설정해야한다. |
* 패스워드 잠금 설정(Lock) 명령: passwd -l 계정명
* 패스워드 잠금 해제(unlock) 명령: passwd -u 계정명
*   Unix(SunOS)의 /etc/shadow 파일의 설정 내용은 Linux와 차이가 있다.

    | 기호     | 설명                                                            |
    | ------ | ------------------------------------------------------------- |
    | NP     | No Password의 의미로 로그인할 수 없는 계정이다. 시스템 및 애플리케이션 계정 용도로 주로 사용된다. |
    | \*LK\* | Lock의 의미로 패스워드가 잠긴 상태로 로그인할 수 없다.                             |
    | 빈값     | 패스워드가 설정되지 않은 상태이다. 패스워드가 설정되어 있지 않으면 로그인 시 패스워드 설정 과정이 진행된다. |
* 패스워드 저장 정책 변경
  * `pwconv`: 사용자 계정 패스워드 저장 정책을 shadow 패스워드 정책으로 변경하는 명령어
  * `pwunconv`: 사용자 계정 패스워드 저장 정책을 일반 패스워드 정책으로 변경하는 명령어

#### 프로세스 실행 권한(SUID, SGID)

* UNIX/Linux 시스템에서 프로세스의 자원에 대한 접근 권한을 판단하기 위해 다음과 같은 아이디를 부여한다.
  * RUID(Real User ID): 프로세스를 실행시킨 사용자의 UID
  * RGID(Real Group ID): 프로세스를 실행시킨 사용자의 GID
  * EUID(Effective User ID): 프로세스가 실행 중인 동안에만 부여되는 UID로 자원 접근 권한을 판단하기 위한 UID
  * EGID(Effective Group ID): 프로세스가 실행 중인 동안에만 부여되는 GID로 자원 접근 권한을 판단하기 위한 GID로 사용된다.

**SUID, SGID**

* SUID(Set UID), SGID(Set GID)는 프로세스가 실행 중인 동안에 해당 실행파일의 소유자, 소유그룹의 권하으로 자원에 접근할 수 있도록 하는 권한 설정이다.
* SUID,SGID가 설정되지 않은 프로세스를 실행시키면 RUID와 EUID, RGID와 EGID가 동일하게 설정된다. 즉 프로세스를 실행시킨 사용자의 UID로 RUID와 EUID가 설정되고, 사용자의 GID로 RGID와 EGID가 설정된다. 따라서 실행시킨 사용자의 권한으로 자원에 접근하게 된다.
* SUID,SGID가 설정된 프로세스를 실행시키면 RUID와 RGID는 실행시킨 사용자의 UID, GID로 설정되고 EUID와 EGID는 실행 파일 소유자의 UID,GID로 설정된다. 따라서 실행시킨 사용자와는 무관하게 프로세스가 실행중인 동안에는 실행파일 소유자의 권한으로 자원에 접근하게 된다.
* 특수 권한 비트(SUID,SGID) 설정(8진수/기호)

| 4        | 2        | 1              |
| -------- | -------- | -------------- |
| s (suid) | s (sgid) | t (sticky-bit) |

* 만약 root 소유의 자원에 대해 일반 사용자의 직접 접근을 차단하면서 기능상 필요한 부분만을 접근하도록 허용할 필요가 있는 경우 별도의 root 소유 프로그램을 통해 SUID, SGID를 설정하여 사용하는 것이 보안적인 측면과 운영적인 측며에서 매우 효율적이다. 다만 root 권한이 필요 없는 프로그램에 소유주가 root로 되어 있으면 setuid가 설정되니 경우에는 보안상으로 매우 취약하다. 이런 이유로 관리자는 주기적으로 SUID, SGID가 설정된 프로그램을 확인할 필요가 있다.\
  대표적으로 일반 사용자가 패스워드 변경을 위해 사용하는 passwd 명령어가 있다. passwd 명령어는 root 소유의 실행파일로 SUID, SGID가 설정되어 있기 때문에 root만 접근할 수 있는 /etc/shadow 파일에 접근하여 패스워드를 변경할 수 있다.
*   root 소유의 SUID, SGID 실행 파일을 주기적으로 검사해야한다.

    ```bash
       $ find . -user root \(-perm -4000 -o -perm -2000 \)

       $ chmod -s 실행파일명  # -s 옵션으로 suid, sgid 권한을 모두 제거한다. 
    ```

#### 디렉터리 접근 권한(sticky-bit)

* 일반적으로 공유 디렉터리(e.g /tmp, /var/tmp 등)는 모든 사용자가 이용할 수 있도록 user, group, other에 rwx 권하을 부여한다. 문제는 다른 사용자가 만든 파일을 누구나 삭제 또는 파일명 변경을 할 수 있다는 점이다. 따라서 자유롭게 파일을 생성하되 파일 삭제나 파일명 변경은 소유자만이 가능하도록 할 필요가 있는데 이러한 목적으로 사용되는 특수권한비트가 sticky-bit 이다.
* sticky-bit 가 설정된 디렉터리는 시스템에 있는 모든 사용자가 자유롭게 파일/디렉터리를 생성할 수 있지만 파일 삭제명 변경은 소유자 또는 root만 가능하다.
* Linux의 경우 o+t 로 지정하지만 Unix(SunOS)의 경우 u+t로 지정한다.

## UNIX/Linux 서버 네트워크 보안

#### SSH

* 보안 쉘이란 암호 통신을 이용하여 네트워크 상의 다른 컴퓨터에 접속하여 원격으로 명령을 실행하거나 파일을 조작하는 응용프로그램 또는 프로토콜을 의미한다. 대표 서비스는 다음과 같다.
  * 암호화된 원격 터미널 서비스 제공
  * 암호화된 파일 송수신 서비스 제공
* 기존의 rsh, rlogn, Telnet, FTP 등 평문 송수신 서비스를 대체하기 위해 설계되었으면 디폴트로 22/tcp 포트를 사용한다.

#### 슈퍼 서버 \[inetd 데몬]

**개요**

1. 네트워크 서버/클라이언트 구조에서 다양한 서비스의(FTP, Telnet, SSH, HTTP등) 서버 프로세스(데몬) 동작 방식은 공통점이 존재한다. 실제 서비스를 제공하는 서비스 프로세스를 제외하고는 클라이언트의 접속 요청이 있을 때까지 대기하다가 요청이 들어오면 처리할 프로세스(자식 프로세스)를 실행하는 형태이다.
2. 따라서 효율적인 서버 자원의 활용이라는 측면에서 공통적인 부분을 처리하는 슈퍼 데몬(데몬의 데몬 프로세스라는 의미)을 만들어 개별 서비스를 등록하여 클라이언트의 요청은 슈퍼 데몬이 모두 처리하고 개별 서비스를 호출해주는 방식을 생각해볼 수 있는데 이러한 방식이 바로 슈퍼 데몬(inetd 데몬) 방식이다.
   * Stand-Alone 방식: 개별 서비스별로 서버 프로세스(데몬)가 동작하는 방식으로 속도가 빠른 장점이 있지만 서버 자원도 많이 점유하고 있는 단점이 있다.
   * inetd(xinetd)방식: 슈퍼데몬을 이용하여 개별 서비스를 동작시키는 방식으로 상대적으로 속도가 느리지만 서버 자원을 절약할 수 있다.
3. inetd 데몬은 N개의 개별 서버를 하나로 통합하여 클라이언트로부터 서비스 요청이 들어올 때마다 해당 서비스에 관련된 실행 모듈을 실행해준다.
4. inetd 데몬은 최소 실행시 /etc/inetd.conf 파일의 정보를 참조하여 서비스할 프로그램들에 대한 정보를 얻는다. 시스템 관리자는 inetd 데몬으로 서비스할 프로그램의 특징을 /etc/inetd.conf 파일에 정의해야 한다.
5. TCP Wrapper 서비스(tcpd서버스)와 연동하여 서비스별 호스트 접근제어를 수행할 수 있다.
6. 리눅스 시스템의 경우 xinetd 데몬을 주로 사용한다. 이는 inetd에서 보안과 자원관리 등을 향상시킨 것으로 기능상 큰 차이가 없다.

> inetd.. 언제적 기술인지 모르겠지만 ubuntu에서의 systemd 와 같은 역할로 추측된다.

~~**inetd.conf 파일 구조**~~

**불필요한/취약한 서비스 비활성화**

* 불필요하고 보안상 취약한 다음 서비스들은 비활성화한다.
  * DoS 공격에 취약한 Simple TCP 서비스: echo(7/tcp), discard(9/tcp), daytime(13/tcp), chargen(19/tcp) 등
  * r 계열 서비스 : rlogin, rsh, rexec 등, r계열 서비스는 인증 없이 관리자의 원격 접속을 가능하게 하는 명령어들로 이기종 운영체제 간 백업 등의 용도로 사용되는 경우가 있으나 보안상 매우 취약하므로 사용하지 말아야 한다.
  * 불필요한 rpc 서비스 rpc.cmsd,rusersd 등 분산 환경에서 서버 응용프로긂에 접근하여 작업 호출을 할 수 있는 서비스 버퍼 오버플로우 등 다수의 취약점이 존재하여 침해사고 발생 위험이 있으므로 서비스를 중지해야 한다.
  * 기타 불필요한 서비스: finger, tftp, talk 등의 서비스

#### 접근통제\[TCP Wrapper]

**개요**

* TCP Wrapper는 외부에서 들어오는 클라이언트에 대해 접근통제 기능을 제공한다. 클라이언트의 IP 주소를 확인하여 시스템 관리자가 접근을 허용한 호스트들에 대해서만 서비스를 허용하기 때문에 외부 해킹으로부터 시스템을 보호할 수 있다.
* 접근 허용 및 차단에 관한 판단은 /etc/hosts.allow 와 /etc/hosts.deny 파일에 정의된 호스트 정보(IP 정보)를 기준으로 한다. 이를 통해 외부로부터 접근을 선택적으로 제한할 수 있다.
  * 접근 순서가 중요하다. 먼저 hosts.allow 파일을 참조하여 해당 호스트 정보가 있다면 접근을 허용한다. 없다면 hosts.deny 파일을 참조하여 해당 호스트 정보가 있으면 접근을 차단한다. hosts.deny 파일에도 해당 호스트 정보가 없다면 default로 모든 접근을 허용한다.
* TCP Wrapper를 사용할 경우 해당 서비스의 실행경로에 "/usr/sbin/tcpd"를 명시한다. inetd 데몬은 외부로부터 서비스 요청이 들어올 경우 inetd.conf 파일을 참조하여 실행경로에 설정된 /usr/sbin/tcpd를 실행한다.
* tcpd는 hosts.allow 및 hosts.deny 파일을 참조하여 접근제어를 수행한 수 실행인수로 설정된 서비스를 실행한다.

**host.allow host.deny**

**xinetd 슈퍼데몬**

**개요**

**설정 파일 형식 (일반설정)**

**설정 파일 형식 (접근제어 관련 설정)**

**설정 파일 형식 (로그 관련 설정)**

## PAM(장착형 인증 모듈 Pluggable Authentication Modules)

#### 개요

1. PAM은 리눅스 시스템 내에서 사용되는 각종 애플리케이션 인증을 위해 제공되는 다양한 인증용 라이브러리들을 말한다.
   * 일반적으로 /lib/security 또는 /usr/lib/security 디렉터리에 해당하는 라이브러리가 저장되어 있다.
   * 라이브러리들은 애플리케이션 인증 목적으로 관리자에 의해 선택적으로 사용할 수 있다. 이를 통해 소프트웨어 개발 시 인증 부분을 독립적으로 개발할 수 있고 필요에 따라 인증체계를 선택적으로 사용할 수 있다는 장점이 있다.
2. 리눅스는 로그인이나 Telnet, FTP 등 각종 프로그램 사용시 PAM을 통해 인증을 처리한다. 프로그램 개발 시 인증 모듈을 별도로 개발하지 않고 플러그인 방식의 PAM을 사용함으로써 인증 방식 및 정책의 유연성과 중앙 통제가 가능하다는 장점이 있다.
3. PAM은 리눅스 시스템에서 사용자 인증의 핵심이며, 각 응용 프로그램에 대한 인증 형태, 사용자 권한, 접근 자원 등을 선택할 수 있는 라이브러리다.
4. 시스템 관리자는 다양한 인증 서비스를 선택할 수 있고, 기존 응용 프로그램을 수정할 필요 없이 새로운 인증 서비스 모듈을 추가하여 사용할 수 있다.

#### PAM을 사용한 인증 절차

1. 각 프로그램은 인증에 필요한 부분에 PAM 라이브러리를 호출한다.
2. PAM 라이브러리가 호출되면 해당 프로그램의 PAM 설정 파일을 참조하여 등록된 여러 PAM 모듈들을 수행하고 그 결과를 응용 프로그램에 반환한다.
3. 응용 프로그램은 그 반환된 결과를 이용하여 인증 여부를 결정한다.
4. PAM 라이브러리 관련 경로는 다음과 같다.
   * /etc/pam.d: PAM 라이브러리를 이용하는 각 응용프로그램(서비스)의 설정 파일이 위치한다. 설정 파일명은 응용 프로그램명과 동일하다.
   * /lib/security: PAM 라이브러리가 제공하는 다양한 인증 모듈들이 위치한다.
   * /etc/security: PAM 모듈 실행에 필요한 추가 설정 파일이 위치한다.

#### PAM 설정파일

| type | control | module-path | module-arguments |
| ---- | ------- | ----------- | ---------------- |
| 1    | 2       | 3           | 4                |

1. type: PAM 모듈 종류
   * account: 서비스 사용자 계정의 유효성을 검증하는 유형으로 계정의 유효기간, 접속가능시간, 서비스 접근 허용 여부 등이 있다.
   * auth: 서비스 사용자 계정의 패스워드 검증, 다른 인증 모듈과의 연동 등 사용자 신원확인을 수행하는 유형으로 패스워드 인증, OTP/보안카드를 통한 인증이 있다.
   * password: 서비스 사용자 계정의 비밀번호 설정 및 변경 조건을 지정하는 유형으로 패스워드 설정/변경 시 최소 길이 복잡도 설정 등이 있다.
   * session: 서비스 사용자 계정의 인증 처리 전후에 수행할 작업을 지정하는 유형으로 사용자 홈 디렉터리 마운트, 메일함 생성 등이 있다.
2. control: 각 모듈 실행 후 성공 또는 실패에 따른 PAM 라이브러리 행동 결정
   * requisite: 인증에 실패할 경우 즉시 인증 거부
   * required: 인증에 실패하더라도 다음 라인의 모듈을 실행하지만 최종 결과는 인증 실패
   * sufficient: 이전 단계 요청된 모듈이 실패하더라도 여기서 성공하면 PAM은 인증 성공(단, 이전에 있는 required 모듈이 모두 성공일 경우)
   * optional: 모듈의 성공 실패결과 모두 무시
3. module-path: PAM에서 사용할 실제 모듈 파일이 위치한 경로를 의미한다. 모듈의 이름(\*.so)만 명시할 경우 기본 PAM 모듈 디렉터리(/lib/security)에서 해당 모듈을 찾는다.
4. module-arguments: 모듈에 전달되는 인수

#### PAM 활용1: root계정의 원격 접속 제한

* root 계정은 시스템을 관리하는 매우 중요한 계정으로 직접 로그인이 가능하면 불법적인 침입자의 목표가 될 수 있다. 따라서 root계정의 원격 접속을 금지한다.
* 터미널 접속시 /etc/security 파일에 등록되어 있는 터미널이 아니면 root의 접속을 허용하지 않도록 PAM 설정
  * /etc/secutiry 파일: pam\_securetty.so 모듈이 사용하는 파일로 터미널 접속 시 root 접근 제한 설정 파일이다.

1.  터미널 접근 시 root 계정을 사용하지 못하도록 하기 위해 /etc/pam.d 디렉터리에 있는 remote 서비스 또는 login 서비스 설정 파일 아래에 다음과 같이 pam\_securetty.so 모듈을 추가한다.

    ```
       auth           required          pam_securetty.so
    ```
2. /etc/securetty 파일에 "pts/\~" 터미널을 모두 제거 또는 주석처리한다.
   * tty(terminal-teletype): 서버와 연결된 모니터, 키보드등을 통해 사용자가 콘솔로 직접 로그인함.
   * pts(pseudo-terminal, 가상터미널): Telnet 터미널 등을 통해 접속하는 가상 터미널을 의미

*   유닉스/리눅스 시스템 별 root 계정 원격 접속 제한 설정

    |         |                                                                                                                                    |
    | ------- | ---------------------------------------------------------------------------------------------------------------------------------- |
    | SOLARIS | <p>#cat /etc/default/login<br>CONSOLE=/dev/console<br>CONSOLE 라인에 # 붙이면 외부에서 root 계정 접속 가능. 그렇지 않으면 콘솔에서만 접속 가능</p>                |
    | LINUX   | <p>#cat /etc/pam.d/login<br>auth required /lib/security/pam_securetty.so<br>cat /etc/securetty<br>pts/0 ~ pts/x 관련 설정이 존재하지 않음</p> |
    | AIX     | <p>#cat /etc/security/user<br>rlogin = false<br>rlogin true로 하면 외부에서 root 계정으로 접속 가능. false로 하면 외부에서 접속이 불가능</p>                   |
    | HP-UX   | <p>#cat /etc/securetty<br>console<br># 붙이면 외부에서 root계정으로 접속이 가능</p>                                                                |
* 취약점 점검 `w` : 점검 결과 root 계정이 pts 타입으로 접속한다면 Telnet 또는 터미널을 통해서 root계정으로 접속한 것으로 판단할 수 있다. root계정은 중요한 계정이므로 원격 터미널 접속을 차단하는 것이 필요하다.
* SSH root 원격 접속 제한 설정
  1. vim /etc/ssh/sshd\_config
  2. PermitRootLogin 항목을 no 로 설정
  3. 설정파일을 저장하고 SSH 데몬 재실행

#### PAM 활용2: 계정 잠금 임계값 설정

* 공격자에 의한 패스워드 브루트포스 공경이나 사전 대입 공격 발생시 암호 입력 실패 횟수를 적절하게 제안하고 공격 시간을 지체시켜 패스워드 유출 위험을 줄인다.
* 계정 잠금 임계값을 설정하여(권장 5회이하) 초과 시 패스워드를 일정시간 잠근다.
* pam\_tally2.so 모듈 이용

1.  계정 잠근 임계 값을 설정하기 위해 /etc/pam.d 디렉터리에 있는 system-auth 서비스 설정 파일에 아래와 같이 pam\_tally2 모듈을 추가한다.

    ```
       auth           required          pam_tally2.so deny=5 unlock_time=120
    ```

    * deny=5: 5회 입력 실패시 패스워드 잠금
    * unlock\_time=120: 계정 잠긴 후 마지막 로그인 실패 시간부터 설정된 시간이 지나면 자동 계정 잠금 해제(단위:초)
    * no\_magic\_root: root 계정은 패스워드 잠금 설정을 적용하지 않는다.
    * reset: 접속 시도 성공시 실패한 횟수 초기화
2. `pam_tally2`
   * `pam_tally2 -u 계정명` 로그인 실패 횟수 확인
   * `pam_tally2 -u 계정명 -r` 해당 계정 실패 횟수 초기화

#### PAM 활용3: root계정 su 제한

* 권한이 없는 일반 사용자가 su 명령을 사용하여 로그인을 시도하고 패스워드 무작위 대입 공격이나 패스워드 추측 공격을 통해 root 권한을 획득할 수 있다.
* su 명령어 사용이 허가된 사용자만 root계정으로 접속할 수 있도록 설정한다.
* pam\_wheel.so 모듈을 이용

1. wheel 그룹(su 명령어 사용그룹)에 su 명령어를 사용할 사용자를 추가한다.
   * `usermod -G wheel 계정명` 명령을 통해 wheel 그룹에 추가한다.
   * 또는 직접 "/etc/group" 파일을 수정하여 필요한 계정을 추가한다.
2.  wheel 그룹의 사용자만 su 명령어를 허용하도록 /etc/pam.d 디렉터리에 있는 su 서비스 설정 파일에 아래와 같이 설정 한다.

    ```
       auth           required          pam_wheel.so use_uid debug
    ```

*   sudo 명령을 통한 root 권한 부여

    * `sudo` 명령은 다른 사용자 계정 권한으로 명령어를 실행하고자 할 때 사용하는 명령이다.
    * `su` 명령을 사용할 경우 관리자의 비밀번호를 알려줘야한다는 부담감이 있으며, 최소 권한의 원칙에 따라 관리자로 로그인 하는 것을 차단하고 권한이 필요한 경우에만 sudo 명령을 사용하여 제한적으로 관리자 권한의 명령어를 실행하는 것을 보안 관점에서 권장한다.
    * sudo 명령어 설정파일: sudoers(/etc/sudoers)

    | 문법 | sudo \[-u 실행권한 계정명] 명령어                         |
    | -- | ----------------------------------------------- |
    | 옵션 | `-u` 명령어를 실행할 때 가질 권한의 계정명, 생략시 root            |
    | 설명 | 하드 링크는 파일에만 가능하고, 심볼릭 링크는 파일 또는 디렉토리에 링크할 수 있다. |

    **sudoers**

    | 계정명 | 호스트명= | 실행권한 계정명 | \[NOPASSWD:]명령어 |
    | --- | ----- | -------- | --------------- |
    | 1   | 2     | 3        | 4               |

1. 계정명: sudo 명령을 실행할 계정명이나 그룹명. 그룹명만 줄 경우 "%그룹명"을 사용하고 모두에게 줄 경우에는 "ALL" 지정
2. 호스트명: sudo 명령을 실행할 호스트의 호스트명 또는 IP, 모든 서버가 대상이면 "ALL"지정
3. 실행 권한 계정명: 명령어를 실행할 떄 가질 권한의 계정명, root를 포함한 모든 계정의 권한을 부여할 경우 "ALL", 생략시 "root"권한 부여
4. NOPASSWD: 해당 옵션을 설정할 경우 sudo 명령을 실행하는 계정의 비밀번호를 물어보지 않는다.
5. 명령어: 실행을 허용할 명령어의 경로, 모든 명령어를 허용할 경우 "ALL"로 지정

## 시스템 로그 설정과 관리

#### 개요

* 유닉스/리눅스 로그가 저장되는 경로는 시스템마다 조금씩 다르다. 일반적으로 유닉스의 경우 /var/adm 디렉터리에 주로 저장되며 리눅스의 경우 /var/log 디렉터리에 주로 저장된다.
* 리눅스에서는 /var/log 디렉터리에서 시스템의 모든 로그를 기록 및 관리하고 있다. 시스템의 /etc/syslog.conf 파일에서 시스템 로그 파일들의 위치를 지정하고 있다.
* 서버에는 여러 개의 로그 파일이 있으며 이들 로그들이 남기는 데몬 또한 다양하다. 시스템 로그데몬(syslogd), 메일데몬(sendmail), 웹데몬(httpd), 네임서버데몬(named), 슈퍼데몬(xinetd) 등 매우 다양하다.

#### 유닉스/리눅스 주요 로그 파일

**utmp(x) 로그 파일 `w`, `who`, `finger`**

/var/log/utmp

* 현재 로그인한 사용자의 상태 정보를 담고 있는 로그파일.
* binary 파일로 되어 있으며 그 내용을 확인하기 위해서는 `w`, `who`, `finger` 등의 명령어를 이용한다.

**wtmp(x) 로그 파일 `last`**

/var/log/wtmp

* 사용자의 성공한 로그인/로그아웃 정보, 시스템의 Boot/Shutdown 정보에 대한 히스토리를 담고 있는 로그 파일
* binary 파일로 되어 있으며 그 내용을 확인하기 위해서는 `last` 명령 사용
  * `last` 명령을 실행하면 모든 계정에 대한 로그인/로그아웃 정보를 출력한다. 특정 계정에 대한 로그인/로그아웃 정보를 보려면 `last 계정명` 형식으로 실행한다.
  * `last` 명령을 통해 계정명, 터미널 타입, 접속 주소, 로그인 시간, 로그아웃 시간 등을 확인할 수 있다.
  * `last reboot` 를 통해 Boot/Shutdown 정보를 확인할 수 있다.

**lastlog 로그 파일 `lastlog`**

/var/log/lastlog

* 가장 최근에 성공한 로그인 기록을 담고 있는 로그 파일
* binary 파일로 저장되어 있으며 그 내용을 확인하기 위해서는 `lastlog` 혹은 `finger` 명령을 사용한다.
  * `lastlog` 명령을 실행하면 모든 계정의 최근 접속 기록을 확인할 수 있다. 자주 사용하는 인수로는 `lastlog -u 계정명`을 통해 사용자 계정을 지정하면 해당 계정의 최근 접속 기록을 확인할 수 있으며 `lastlog -t 일수`를 통해 해당 일수 이내에 접속한 기록을 확인할 수 있다.

**btmp(Linux), loginlog(Unix(SunOS)) 로그 파일 `lastb`**

/var/log/btmp

* 실패한 로그인 시도에 대한 기록을 담고 있는 파일
* Linux: binary 파일로 저장되어 있으며 그 내용을 확인하기 위해서는 `lastb` 명령을 사용한다. 실패한 모든 로그를 남긴다.
* Unix: /var/adm/loginlog, 텍스트 파일로 되어 있으므로 vi 등의 편집기를 통해 로그 내용을 확인해 볼 수 있다. 5회 이상 실패시 실패한 로그를 남긴다.

**sulog 로그 파일 (Unix(SunOS))**

* su(switch user) 명령을 사용한 결과를 저장한 파일로 SunOS를 포함한 Unix 계열에서만 볼 수 있다.
* Unix: /var/adm/sulog, 텍스트 파일로 되어 있으므로 vi 등의 편집기를 통해 로그 내용을 확인할 수 있다.
* Linux 계열의 경우 /var/log/secure 로그 파일에 su 명령을 사용한 결과가 남는다.

**acct/pacct 로그 파일 (Linux/Unix(SunOS))**

* acct/pacct 로그파일은 시스템에 로그인한 모든 사용자가 로그아웃할 때까지 입력한 명령어와 터미널의 종류 프로세스 시작 시간 등을 저장한 로그이다.
* 실행한 명령어, 플래그, 실행한 사용자명, 터미널 타입, 프로세스 시작 시간 정보를 보여준다.
* 플래그 정보에는 S(root에 의해 실행), F(exec 없이 fork에 의해 실행), X(SIGTERM 시그널에 의해 종료) 등이 있다.
* binary 파일로 되어 있으며 그 내용을 확인하기 위해서는 `lastcomm` 명령어를 사용한다.
* Linux: /var/account/pacct, 기본 생성되는 로그파일이 아니므로 `accton /var/account/pacct` 명령 실행이 필요하다.
* Unix: /var/adm/pacct, 기본 생성되는 로그파일이 아니므로 `/usr/lib/acct/accton /var/adm/pacct` 명령 실행이 필요하다.

**histroy 로그 파일 (Linux/Unix(SunOS)) `history`**

* 계정별로 실행한 명령어에 대한 기록을 저장한 파일로 계정별 홈 디렉터리에 존재한다. 로그파일은 ".쉘\_history" 형식으로 생성되며 텍스트 파일로 되어 있으므로 vi 등의 편집기를 사용해 로그를 확인하거나 `history` 명령어를 이용할 수 있다.

**secure 로그 파일(Linux)**

/var/log/secure

* 주로 사용자/그룹 생성/삭제, 로그인 등의 사용자 인증에 대한 정보를 기록하고 있는 로그파일로서 서버 보안에 아주 민감하고 중요한 파일이다.
* 원격에서 접속한 내역과 `su` 명령을 수행한 내역등이 저장된다.

**messages 로그 파일(Linux)**

/var/log/messages

* 리눅스 시스템의 가장 기본적인 시스템 로그파일로 시스템 운영에 대한 전반적인 메시지를 저장하고 있다.
* 주로 시스템 데몬들의 실행상황과 내역, 사용자들의 접속정보, TCP Wrapper 접근 제어 정보 등을 저장한다.

**dmesg 로그 파일(Linux) `dmesg`**

/var/log/dmesg

* 리눅스가 부팅될 때 출력되는 모든 메시지를 기록하고 있다. 부팅 시의 에러나 조치사항을 살펴보려면 이 파일을 참조해야한다.
* 텍스트 형식의 로그 파일을 보거나 `dmesg` 명령을 통해 내용을 확인할 수 있다.

**boot.log 로그 파일(Linux)**

/var/log/boot.log

* 리눅스가 부팅될 때 파일시스템에 대한 체크, 서비스 데몬들의 실행 상태 등을 기록하고 있는 로그파일로 성공/실패 여부를 확인할 수 있다.

**xferlog 로그 파일(Linux)**

/var/log/xferlog

* 리눅스 시스템의 FTP 서비스 로그파일로 vsFTP, ProFTP 등 다양한 FTP 서버 프로그램에서 서비스 내역을 기록하고 있다.
* FTP 접속 일시, 원격 호스트와 사용자 정보, 업로드/ 다운로드한 파일 등 다양한 정보를 상세하게 기록한다.

**cron 로그 파일 (Linux)**

/var/log/cron

* 시스템에서 동작중인 cron 데몬이 수행한 정기적인 작업을 기록한 로그

**maillog 로그 파일 (Linux)**

/var/log/maillog

* 시스템에 동작중인 메일서버 (e.g. sendmail등) 의 메일 송수신 관련 작업을 기록한 로그파일.\


\


#### syslog 설정 및 관리

**개요**

1. 유닉스 시스템은 syslog 표준 인터페이스를 통해 커널 및 응용프로그램에서 발생하는 로그를 체계적으로 생성하고 관리한다.
2. 동작 방식을 상펴보면 커널 및 응용프로그램이 syslog API 를 통해 로그를 생성하면 syslogd데몬 프로세스가 syslog.conf 설정파일을 참조하여 지정한 로그파일, 콘솔 또는 외부서버로 로그를 기록한다.
   * syslog API 사용구문: syslog(priority, "%s",'로그 문자열')
3.  /etc/syslog.conf 파일은 시스템 로그 데몬(syslogd)이 실행될 때 참조되는 로그설정 파일로서 어떤 로그를 어디에 남길지 로그 저장 규칙이 정의되어 있다. syslog.conf 파일의 각 행들은 다음과 같은 포멧으로 정의되어 있다.

    | facility.priority; facility.priority; ... action(logfile-location) |
    | ------------------------------------------------------------------ |
    |          A.B                    A.B                         C      |

    * A 서비스(데몬)에 대하여 B로그 레벨 이상의 상황이 발생한 경우 C 형식의 로그를 남기라는 의미이다.
4. 최근 리눅스에서는 기존 syslog를 개선한 rsyslog를 주로 사용한다.
   * rsyslogd(로그 데몬) 데몬 프로그램과 /etc/rsyslog.conf 설정 파일을 사용한다.
5. syslog는 기밀성, 무결성, 가용성 등 정보보호 특성을 고려하지 않고 개발되어 UDP를 통해 로그를 전송할 때 공격자가 syslog 메시지를 모니터링하여 중요 정보를 알아낼 수 있다. 이 때문에 RFC 3195(Reliable Delivery for syslog)에서는 다음과 같은 보안 기능을 제공하도록 권고하고 있다.
   * 로그 전송의 신뢰성을 보장하기 위해 연결 지향 프로토콜인 TCP를 이용하도록 권고.
   * syslog 메시지 전송 시 기밀성 보장을 위해 syslog 서버 및 log 수집 대상 서버의 IP를 제외한 payload를 보호할 수 있는 BEEP를 이용하도록 권고
   * BEEP(the Blocks Extensible Exchange Protocol): 연결 지향적이고, 비동기적인 연결을 위한 응용 프로그램 프로토콜 프레임워크로 내부적으로 인증, 프라이버시, 재전송을 통한 신뢰성을 보장

**facility: 로그 생성 서비스**

|         facility        | 설명                                        |
| :---------------------: | ----------------------------------------- |
|            \*           | 모든 서비스                                    |
| <p>auth<br>authpriv</p> | 인증 및 보안 관련 메시지                            |
|           cron          | cron 데몬과 atd 데몬에 의해 발생되는 메시지              |
|          daemon         | telnet, ftp등 과 같은 데몬에 의한 메시지              |
|           kern          | 커널에 의한 메시지로 커널 메시지라고 함                    |
|           lpr           | 프린터 데몬인 lpd에 의해 발생하는 메시지                  |
|           mail          | sendmail, pop, qmail 등의 메일 시스템에서 발생하는 메시지 |
|           news          | USENET 등과 같은 뉴스시스템에 의해 발생되는 메시지           |
|           uucp          | uucp에 의한 시스템 메시지                          |
|           user          | 사용자에 의해 생성된 프로세스                          |
|          syslog         | syslogd에 의해 발생되는 메시지                      |
|     local0 \~ local7    | 시스템 부팅 메시지 기록, 기타 여분 서비스(확장)에 사용하기 위함     |

**priority: 로그 수준**

* facility에 로그 수준을 지전하게 되면 해당 수준 이상의 상황이 발생했을 때 로그가 남게 된다.
* syslog.conf에 로그수준을 '\*'로 지정하면 모든 수준의 로그를 남기겠다는 의미이며, "none"으로 설정하면 어떠한 경우에도 로그를 남기지 않겠다는 의미이다.

|           Priority          | 설명                                                                           |
| :-------------------------: | ---------------------------------------------------------------------------- |
| <p>Emergency<br>(emerg)</p> | <p>* 시스템이 전면 중단되는 패틱 상태, 전체 공지가 필요한 상황<br>* system is unusable</p>           |
|             alet            |                                                                              |
|   <p>alert<br>(alert)</p>   | <p>* 즉각적인 조치가 필요한 상황(시스템 데이터베이스 오류)<br>*action must be taken immediately</p> |
|  <p>Critical<br>(crit)</p>  | <p>* 하드웨어 등의 심학한 오류가 발생한 상황<br>* critical condition</p>                      |
|    <p>Error<br>(err)</p>    | <p>* 일반적인 에러/오류가 발생한 상황<br>* error condition</p>                             |
| <p>Warning<br>(warning)</p> | <p>* 경고메시지<br>* warning condition</p>                                        |
|  <p>Notice<br>(notice)</p>  | <p>* 에러/오류는 아니지만 관리자의 조치가 필요한 상황<br>* normal, but significant condition</p>  |
| <p>Infomation<br>(info)</p> | <p>* 의미있는 정보 관련 메시지<br>* information message</p>                             |
|   <p>debug<br>(debug)</p>   | <p>* 디버깅용 메시지<br>* debug-level message</p>                                   |

**action**

* 로그를 어디에 남길 것인지를 결정한다. 로그파일, 콘솔, 원격 로그 서버, 특정 사용자 등에 로그를 남길 수 있다.
  * 로그파일: 파일명(경로) 지정(e.g. /var/log/secure)
  * 콘솔: /dev/console 지정시 콘솔 출력
  * 원격 로그 서버: "@호스트주소"를 통해 지정한 호스트로 로그를 보낸다.
  * user: 지정된 사용자의 스크린으로 메시지를 보낸다. (e.g. root)
  * \* : 현재 로그인된 모든 사용자의 스크린으로 메시지를 보낸다.

~~**syslog.conf**~~

#### 리눅스 로그 관리

**로그 모니터링**

* `tail -f` 명령으로 텍스트 형식의 로그를 실시간 모니터링
* utmp, wtmp, lastlog 등 바이너리 형식의 로그파일을 cat이나 vi 등의 텍스트 편집기를 통해서 확인할 수 없다. 따라서 별도의 명령어를 이용하여 확인해야 한다.

**로그 파일 순환(rotate) 관리**

* syslog, 데몬 프로세스 등이 출력하는 로그파일은 그대로 방치하면 크기가 커져 관리하기 어려워지고 디스크 사용률이 100%가 되어 시스템 장애가 발생할 수 있는 문제가 있다.
*   logrotate는 시스템 로그 파일을 관리하기위한 도구로 로그 파일 순환 압축등 다양한 기능을 제공한다.

    | 구분         | 위치 및 실행방법                 | 설명                                               |
    | ---------- | ------------------------- | ------------------------------------------------ |
    | 데몬(위치)     | /usr/sbin/logrotate       | logrotate 데몬 위치 및 데몬 프로그램                        |
    | 데몬설정 파일    | /etc/logrotate.conf       | logrotate 설정 파일                                  |
    | 설정 디렉터리    | /etc/logrotate.d          | logrotate를 적용할 프로세스의 개별 설정 파일이 위치한 디렉터리          |
    | 상황 파일      | /var/lib/logrotate.status | logrotate를 수행한 작업 내역들을 보관한 파일                    |
    | cron(일 단위) | /etc/cron.daily/logrotate | logrotate는 주기적으로 실행되어야 하므로 cron 데몬에 의해 일 단위로 실행됨 |

## UNIX/Linux 서버 취약점

#### UNIX/Linux 서버 계정 관리

1.  root 이외의 UID가 0 금지

    * root(UID=0)와 동일한 UID를 가진 계정 존재 시 root 권한으로 시스템 접근이 가능하므로 root의 UID를 가진 계정이 존재하지 않도록 확인
    * root 이외의 계정이 UID=0 인 경우 0이 아닌 적절한 UID를 부여하거나 불필요한 계정일 경우 삭제

    | OS                                 | 명령어                    |
    | ---------------------------------- | ---------------------- |
    | <p>SOLARIS,<br>LINUX,<br>HP-UX</p> | usermod -u 2023 ehdcjf |
    | AIX                                | chuser id=2023 ehdcjf  |

\


2. 패스워드 복잡성 설정 \_ 사용자 계정 암호를 유추하기 쉽게 설정하면 비인가자의 시스템 접근을 허용하게 하는 위험이 존재한다. \_ 패스워드 관리 방법 1. 영문, 숫자, 특수문자를 조합하여 계정명과 상이한 8자 이상의 패스워드를 설정한다. 2. 영문 대문자, 영문 소문자, 숫자, 특수문자 중 2종류 이상을 조합하여 최소 10자리 이상 또는 3종류 이상을 조합하여 최소 8자리 이상의 길이로 구성한다. 3. 시스템마다 상이한 패스워드를 사용하고 패스워드를 기록할 경우에는 변형하여 기록한다. 4. 가급적이면 자주 패스워드를 변경한다.\

3. 패스워드 최소 길이 설정
   * 패스워드 무차별 공격이나 패스워드 추측 공격에 대응하기 위해 패스워드 최소 길이 설정이 필요하다. 최소 8자 이상.

\


4. 패스워드 최대 사용기간 설정
   * 패스워드 최대 사용기간을 설정하지 않으면 일정 기간 경과 후에도 유출된 패스워드로 접속할 수 있다.
   * 악의적인 사용자의 계속된 접속을 차단하기 위해 패스워드 최대 사용기간을 설정하여 주기적으로 변경할 수 있도록 한다.
   * 최대 사용 기간을 90일(12주)로 설정한다.

\


5. 패스워드 최소 사용기간 설정
   * 패스워드 최소 사용기간을 설정하지 않으면 사용자에게 익숙한 패스워드로 쉽게 변경할 수 있으며 이를 재사용함으로써 패스워드의 정기적 변경은 무의미해질 수 있다.
   * 패스워드 최소 사용기간을 1일(1주)로 설정한다.

\


6. 패스워드 파일 보호
   * 패스워드 정보를 평문으로 저장하는 경우 정보 유출 피해가 발생할 수 있으므로 패스워드를 암호화하여 보호해야한다.
   * shadow 패스워드를 사용하여 "/etc/shadow" 파일에 암호화된 패스워드가 저장되도록 하고 권한이 있는 사용자들만 읽을 수 있도록 제한한다.

\


7. Session Timeout 설정 \* 계정이 접속된 상태로 방치되면 권한이 없는 사용자에게 중요한 시스템이 노출되어 악의적인 목적으로 사용될 수 있으므로 일정 시간 이후 어떠한 이벤트가 발생하지 않으면 연결을 종료하는 Session Timeout 설정이 필요하다.\


#### 파일 및 디렉터리 관리

1. root HOME, PATH 디렉터리 권한 및 PATH 설정 \_ root 계정의 PATH 환경변수에 "."이 포함되어 있으면 root 계정으로 접속한 관리자가 의도하지 않은 현재 디렉터리에 위치하고 있는 명령어가 실행될 수 있다. 즉 "."이 /usr/bin, /sbin 등의 명령어들이 위치하고 있는 디렉터리보다 우선하여 위치하고 있을 경우, root 계정으로 접속한 관리자가 특정 명령을 실행하면 불법적으로 현재 디렉터리에 위치시킨 파일을 실행하여 예기치 않은 결과를 가져올 수 있다. \_ PATH 환경 변수에 "."이 맨 앞 또는 중간에 위치하고 있으면 root 가 의도하지 않은 명령이 실행될 수 있으므로 PATH 환경변수의 마지막으로 이동시키거나 불필요한 경우 삭제한다.\

2.  파일 및 디렉터리 소유자/소유그룹 설정

    * 소유자/소유그룹이 존재하지 않는 파일 및 디렉터리는 현재 없는 소유자/소유그룹의 소유였거나, 관리 소홀로 인해 생긴 파일일 가능성이 있다.
    * 사용하지 않는 디렉터리나 파일일 경우 시스템 자원 낭비가 될 수 있고 중요한 파일 및 디렉터리일 경우 관리가 되지 않는 문제가 있다.
    * find 명령의 -nouser -nogroup 옵션을 통해 소유자/소유자그룹이 존재하지 않는 파일/디렉터리를 검색

    ```sh
        $ find .\( -nouser -o -nogroup \) -exec ls -al {} \;
    ```

    * 파일 소유자/소유그룹 변경 또는 불필요 시 삭제 chown 또는 chgrp 명령을 통해 소유자/소유그룹을 변경한다.
3.  world writable 파일 점검 \_ "world writable" 파일이란 모든 사용자(others)에게 쓰기 권한이 부여된 파일을 말한다. \_ 모든 사용자가 접근 및 수정할 수 있는 권한으로 설정된 파일이 존재하면 일반 사용자의 실수 또는 악의적으로 주요 파일 정보를 변경할 수 있으므로 시스템 장애나 추가적인 공격에 활용될 수 있는 문제가 있다. \* find 명령의 "-perm -2" 옵션을 통해 others에 쓰기(w) 권한이 부여된 파일/디렉터리를 검색, others에 대한 쓰기 권한을 제거하거나 불필요한 파일/디렉터리인 경우 삭제

    ````sh
    $ find /home/ehdcjf -perm -2 -exec ls -al {} \;

               $ find /home/ehdcjf -perm -0002 -exec ls -al {} \;

               # 권한 제거
               $ chmod o-w /home/ehdcjf/sample.config

               # 파일 삭제
               $ rm -rf /home/ehdcjf/sample.config

           ```

       <br>

    ````
4. 주요 파일 소유자 및 권한 설정
   * /etc/passwd : 사용자 정보를 담고 있는 파일로 root 소유의 644 이하의 권한 설정
   * /etc/shadow : 사용자의 암호화된 패스워드 정보를 담고 있는 파일로 root 이외에는 접근 못하도록 root 소유의 400 이하의 권한을 설정
   * /etc/host : IP와 호스트 이름을 매핑하는데 사요되는 파일로 외부의 불법적인 접근에 의한 조작 시 악의적인 시스템에 접근할 가능성이 있으므로 root 소유의 600 이하의 권한을 설정한다.
   * /etc/(x)inetd.conf : inetd 데몬에 대한 설정파일로 외부의 불법적인 접근에 의해 악의적인 프로그램을 등록하고 root 권한으로 실행할 가능성이 있으므로 root 소유의 600 이하의 권한을 설정한다.
   * /etc/syslog.conf : syslogd 데몬에 대한 설정파일로 주요 로그파일에 대한 설정 정보를 가지고 있다. 해당 파일의 접근권한이 적절하지 않아 외부의 불법적인 접근에 의하여 변경되는 경우 시스템 로그가 정상적으로 기록되지 않아 외부의 불법적인 접근에 의해 변경되는 경우 시스템 로그가 정상적으로 기록되지 않아 침입자의 흔적 또는 시스템 오류 사항을 정확히 분석할 수 없으므로 root 이외의 사용자는 해당 파일을 변경할 수 없도록 root 소유의 644 이하의 권한을 설정한다.
   * /etc/services : 서비스 관리(서비스별 포트/프로토콜 정보)정보를 담고 있는 파일로 접근 권한이 적절하지 않아 외부의 불법적인 접근에 의해 변경되는 경우 정상적인 서비스를 제한하거나 허용되지 않는 서비스를 등록하는 등의 위험이 있으므로 root 소유의 644 이하의 권한을 설정한다.
